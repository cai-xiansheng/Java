Java基础



+ 编译 `.java` 为 `class` 文件：`javac Welcome.java`
+ 执行：`java Welcome`



## 数据类型和运算符

### 注释

```java
//单行注释
/*
多行注释
	*/
/**
 *文档注释
 */
```

1. 在类的方法中使用单行注释
2. 在类中使用文档注释

### 标识符

#### 标识符规则

1. 标识符必须是以字母、下划线、美元符号开头。
2. 标识符其他部分可以是字母、下划线、美元符、数字的任意组合。
3. Java标识符大小写敏感，且长度无限制。
4. 标识符不可以是Java关键字。

#### 标识符使用规范

1. 表示`类名`的标识符：每个单词的手写字母大写.Man,GoodMan
2. 表示方法和变量的标识符，第一个的单词小写，从第二个单词开始首字母大写。（也就是驼峰法命名）。

### Java中的关键字/保留字

| abstract   | assert  | boolean   | break     | byte       | case        |
| ---------- | ------- | --------- | --------- | ---------- | ----------- |
| catch      | char    | class     | const     | continue   | default     |
| do         | double  | else      | extends   | final      | finally     |
| float      | for     | goto      | if        | implements | import      |
| instanceof | int     | interface | long      | native     | new         |
| null       | package | private   | protected | public     | return      |
| short      | static  | strictfp  | super     | switch     | sychronized |
| this       | throw   | throws    | transient | try        | void        |
| volatile   | while   |           |           |            |             |

### 变量

#### 变量的本质

1. 变量的本质上就是代表一个“可操作的存储空间”，空间的位置是确定的，到那时里面放置什么值不确定。
2. 我们可以通过变量名来访问“对应的存储空间”，从而操作这个“存储空间”存储的值。

#### 变量的分类

| 类型                 | 声明位置           | 从属于      |                           声明周期                           |
| -------------------- | ------------------ | ----------- | :----------------------------------------------------------: |
| 局部变量             | 方法或语句块内部   | 方法/语句块 |   从声明位置开始，直到方法或语句块执行完毕，局部变量消失。   |
| 成员变量（实例变量） | 类内部，方法外部   | 对象        | 对象创建，成员变量也跟着创建，对象消失，成员变量也跟着消失。 |
| 静态变量（类变量）   | 类内部，static修饰 | 类          |      类被加载，静态变量就有效；类被卸载，静态变量消失。      |

### 常量

1. 常量通常是指一个固定的值。
2. 在Java中，主要是利用 `final` 来定义一个常量。常量一旦被初始化后不能在更改其值。
3. 常量声明格式 `final type varname = value;`

#### 变量和常量命名规范

1. 多有变量、方法、类名：见名知意
2. 类成员变量：首字母小写和驼峰法原则：monthSalary
3. 局部变量：首字母小写和驼峰原则
4. 常量：大写字母和下划线：MAX_VALUE
5. 类名：首字母大写和驼峰原则
6. 方法名：首字母小写和驼峰原则：run()

### 基本数据类型

+ Java的数据类型可分为两大类：基本数据类型（primitive data type）和引用数据类型（reference data type）。
+ 数值值 - byte、short、int、long、float、double
+ 字符型 - char
+ 布尔型 - boolean

![image-20200409115800605](C:\Users\张辉\Desktop\日常记录\笔记\Java学校\image-20200409115800605.png)

#### 整形变量/常量

| 类型  | 占用存储空间 | 表数范围                   |
| ----- | ------------ | -------------------------- |
| byte  | 1字节        | -2^7 ~ 2^7-1（-128 ~ 127） |
| short | 2字节        | -2^15 ~ 2^15 - 1（3万）    |
| int   | 4字节        | -2^31 ~ 2^31 - 1（21亿）   |
| long  | 8字节        | -2^63 ~ 2^63 - 1           |

1. 十进制整数：99，-500
2. 八进制整数，要求以0开头：015
3. 十六进制数，要求以0x或0X开头：0x15
4. 二进制数，要求以0b或0B开头：0b01110011
5. `long` 型常量声明时必须加`L` ，不然会别编译为int，还会报错： `long b = 5555555555555555555555L;`

#### 浮点型变量/常量

| 类型   | 占用存储空间 | 表数范围               |
| ------ | ------------ | ---------------------- |
| float  | 4字节        | -3.403E38 ~ 3.403E38   |
| double | 8字节        | -1.798E308 ~ 1.798E308 |

1. 带小数的数据在Java中称为浮点数。浮点数可分为 `float` 类型和 `double` 类型。
2. `float` 类型又被称为单精度类型，尾数可以精确到 `7` 位有效数字，在很多情况下， `float` 类型的精度很难满足需求。
3. `double` 类型的数值的精度约是 `float` 类型的两倍，又被称作双精度类型，绝大多数部分的应用程序都采用 `double` 类型，
4. 浮点数常量的默认类型也是 `double`。
5. `float` 类型的数值有一个后缀 `f` 或者 `F` ，没有后缀 `f/F`的浮点数被默认为 `double` 类型。
6. 浮点数 `float/double` 的数据不适合在不允许舍入误差的领域。
7. `BigDecimal` 类不产生舍入误差，实现了任意精度的浮点运算。 ` BigDecimal bd = BigDecimal.valueOf(1.0); ` 加减乘除使用的相关方法。
8. `BigInteger` 实现了任意精度的整数运算。

##### Java浮点类型常量有两种表示形式

+ 十进制数形式：3.14，314.0，0.314
+ 科学记数形式：314e2，314E2，314E-2

#### 字符型变量/常量

1. 字符型在Java中占2个字节。

2. 在Java职工使用单引号来表示字符常量：'A'

3. char 类型用来表示在 Unicode 编码表中的字符。

4. 转义字符

   | 转义符 | 含义            | Unicode值 |
   | ------ | --------------- | --------- |
   | \b     | 退格(backspace) | \u0008    |
   | \n     | 换行            | \u000a    |
   | \r     | 回车            | \u000d    |
   | \t     | 制表符(tab)     | \u0009    |
   | \\"    | 双引号          | \u0022    |
   | \\'    | 单引号          | \u0027    |
   | \\\    | 反斜杠          | \u005c    |

5. String的底层实现就是字符序列。

#### boolean 类型

1. `boolean` 类型有两个常量值： `true/false` 
2. `boolean` 在内存中占一位（不是一个字节）。
3. 不可以用`0/1`表示`true/false`

### 运算符

![image-20200409141113851](C:\Users\张辉\Desktop\日常记录\笔记\Java学校\image-20200409141113851.png)

#### 算数运算符

+ 二元运算符：+，-，*，/，%
+ 二元运算符顾名思义就是需要两个操作数才能完成运算的运算符
+ 一元运算符：++，--

##### 整数运算规则

1. 如果两个操作数有一个位 `long` ，则结果也为long。
2. 没有long时，结果位int。即使操作数全部为short，byte，结果也是int。

##### 浮点数运算规则

1. 如果两个操作数有一个为 `double` ，则结果为 `double`。
2. 只有两个数都是 `float` ，则结果才会为`float`

##### 取模运算规则

1. 操作数可以为浮点数，一般使用整数，结果是余数。
2. 余数的符号和左边的操作数相同：7%3=1，-7%3=-1，7%-3=1。

#### 赋值及其扩展赋值运算符

1. `+=,-=,*=,/=,%=`
2. 这些扩展运算符都是压缩了运算。

#### 关系运算符

![image-20200409142530815](C:\Users\张辉\Desktop\日常记录\笔记\Java学校\image-20200409142530815.png)

1. `=` 是赋值运算符
2. `==,!=` 是所有（基本和引用）数据类型都可以使用；但是在使用 `==` 的情况下一般都使用 `equals`
3. `>,>=,<,<=` 仅针对数值类型（byte/short/int/long，float/double，以及char）

#### 逻辑运算符

![image-20200409161634952](C:\Users\张辉\Desktop\日常记录\笔记\Java学校\image-20200409161634952.png)

1. 逻辑运算的操作数和运算结果都是boolean值。
2. 短路与和短路或采用短路的方式。从左到右计算，如果只通过运算操作符左边的操作数就能够确定该逻辑表达式，则不会继续计算操作符右边的操作数，提高效率。

#### 位运算

![image-20200409162426494](C:\Users\张辉\Desktop\日常记录\笔记\Java学校\image-20200409162426494.png)

![image-20200409162917922](C:\Users\张辉\Desktop\日常记录\笔记\Java学校\image-20200409162917922.png)

1. `&` 和 `|` 即使逻辑运算符，也是位运算符。如果两侧的操作数都是boolean类型，就作为逻辑运算符。如果两侧的操作数是整数类型，就是位运算符。
2. `^` 不是数学的乘方，而是 `位的异或` 操作。
3. `&` 按位与：可以实现清零的功能。

#### 字符串连接符(+)

> `+` 运算符两侧的操作数中只要有一个是字符串（String）类型，系统会自动将另一个操作数转为字符串然后再进行连接。

#### 条件运算符

> x ?  y  :  z; 

#### 算数运算符优先级

![image-20200409164431515](C:\Users\张辉\Desktop\日常记录\笔记\Java学校\image-20200409164431515.png)

1. 一般使用小括号来组织。
2. 逻辑非>逻辑与>逻辑或

### 类型转换

#### 自动类型转换

1. 自动类型转换指的是容量小的数据类型可以自动转换为容量大的数据类型。
2. 当整数转为浮点数的时候，会出现精度损失。
3. 可以将整形常量直接赋值给byte,short,char等类型。不需要进行强制类型转换，只要不超过其数范围即可。

#### 强制类型转换

1. 强制类型转换，又被称为造型，用于显式的转换一个数值的类型。
2. 将一种类型强制转换成另一种类型，而又超出了目标类型的范围，就会被截断为一个完全不同的值。
3. `不能在布尔类型` 和任何数值类型之间做强制类型转换。

##### 强制类型转换时常见的错误和问题

1. 操作较大的数时，要留意是否溢出。
2. `L/l` 的使用，可能和 `1` 造成混乱。需要注意。

## 控制语句

> 所有的布尔表达式中不能使用 `0/1` 进行判断处理

### 选择结构

#### if单选择结构

```java
if (布尔表达式) {
    语句块
}
```

#### if-else双选择结构

```java
if(布尔表达式){
    语句块1
}else{
    语句块2
}
```

#### if-else if-else多选择结构

```java
if(布尔表达式1) {
	语句块1;
} else if(布尔表达式2) {
	语句块2;
}……
else if(布尔表达式n){
    语句块n;
} else {
    语句块n+1;
}
```

#### switch 多选择结构

```java
switch (表达式) {
case 值1: 
	语句序列1;
	[break];
case 值2:
 	语句序列2;
[break];
     … … …      … …
[default:
 	默认语句;]
}
```

+ 这儿的表达式就是填入一个变量，然后与下面的值对比。
+ `default` 语句可以有，也可以舍去。

### 循环结构

+ 循环结构分为两大类：一类是当型，一类是直到型。
+ 当型：当布尔表达式条件为 true 时，反复执行某语句，当布尔表达式的值为 false 时才停止循环。比如：while/for 循环。
+ 直到型：先执行某语句，再判断布尔表达式，如果为 true，再执行某语句，如此反复直到布尔表达式条件为 false 时才停止。比如：do-while 循环。

#### while循环

```java
while (布尔表达式) {
    循环体；
}
```

#### do-while循环

```java
do {
    
} while (布尔表达式);
```

+ do-while 循环的结尾必须有 `;` 
+ while 与 do-while 的区别：do-while 总是保证循环体至少被执行一次。

#### for循环

```java
for (初始表达式; 布尔表达式; 迭代因子) {
	循环体;
}
```

+ A. 初始化部分设置循环变量的初值

+ B. 条件判断部分为任意布尔表达式

+ C. 迭代因子控制循环变量的增减

+ for循环在执行条件判定后，先执行的循环体部分，再执行步进。

#### 嵌套循环

1. break

   + 用于强制退出，不执行循环剩余的语句

2. continue

   + 终止本次循环
   + continue用在while，do-while中，continue 语句立刻跳到循环首部，越过了当前循环的其余部分。
   +  continue用在for循环中，跳到for循环的迭代因子部分。

3. 可以在 `break/continue` 加标签，这样就可以实现多层跳转。

   ```java
    outer: for (int i = 101; i < 150; i++) {
               for (int j = 2; j < i / 2; j++) {
                   if (i % j == 0){
                       continue outer;
                   }
               }
               System.out.print(i + "  ");
           }
   ```

### 方法

#### 语句块

+ 语句块就是方法中的`{}`

#### 方法

1. 格式 

   ```java
   [修饰符1  修饰符2  …]   返回值类型    方法名(形式参数列表){
       Java语句；… … …
    }
   ```

2. 对象的调用方式： `对象名.方法名(实参列表)`

3. 方法的详细说明

   1. 形式参数：在方法生命时用于接受外界传入的数据。
   2. 实参：调用方法时实际传入给方法的数据
   3. 返回值：方法在执行完毕后返回给调用它的环境数据。
   4. 返回值类型：事先约定的返回值的数据类型，如无返回值，必须显式的指定为void

4. Java中进行的方法调用中传递参数时，遵循值传递的原则（传递的都是数据的副本）

5. 基本类型传递的是该数据值的 copy 值。

6. 引用类型传递的是该对象应用的 copy 值，但是指向的是同一个对象。

#### 方法的重载（overload）

1. 方法的重载是指一个类中可以定义多个方法名相同，但参数不同的方法。
2. 方法调用时，会根据不同参数自动匹配对应的方法。

### 递归结构

1. 递归结构包括两个部分：递归头，递归体
2. 递归头：没有递归头会陷入死循环，递归头就是定义了一个判断的条件。
3. 递归体：什么时候需要调用自身的方法。

## 数组

### 数组的定义

1. 数组是相同类型数据的有序集合。
2. 数组的长度是确定的。数组一旦被创建，它的大小就是不可以改变的。
3. 其元素必须是相同的类型，不允许出现混合类型。
4. 数组类型可以是任何数据类型，包括基本类型和引用类型。
5. 注意：
   1. 数组变量属于引用类型，数组可以看成是对象，每个数组中的每个元素相当于该对象的成员变量。
   2. 数组本身就是对象，Java中对象是堆中的，因此数组无论保存原始类型还是其他对象类型，数组对象本身是在堆中存储的。

### 数组的声明

```java
type[] arr_name;
```

1. 声明的时候并没有实例化任何对象，只有在实例化数组对象时，JVM 才会分配空间，这时候才与长度有关。
2. 声明一个数组的时候并没有数组被真正的创建。
3. 构造一个数组，必须指定数组的长度。

### 数组的初始化

#### 静态初始化

```java
int[] a = {1,4,7};
User[] b = {        
    new User(1001,"zs"),        
    new User(1002,"zed")
};
```

#### 动态初始化

```java
int[] a1 = new int[2];//动态初始化数组，先分配空间；
a1[0]=1;//给数组元素赋值；
a1[1]=2;//给数组元素赋值；
```

#### 默认初始化

```java
int[] c = new int[3]; // 默认给数组赋值，赋值的规则和成员变量默认赋值规则一致。
```

### 数组的遍历

1. 数组元素下边的合法区间：[0,length-1]
2. 遍历数组时可以读取或修改元素的值。
3. `fori` 遍历：可以修改、读取数组元素的值。
4. `for-each` 遍历：只可以读取元素的值。 

### 数组的拷贝

 System类里也包含了一个 `static void arraycopy(object src，int srcpos，object dest， int destpos，int length)` 方法，该方法可以将 `src` 数组里的元素值赋给 `dest` 数组的元素，其中 `srcpos` 指定从 `src` 数组的第几个元素开始赋值， `length` 参数指定将 `src` 数组的多少个元素赋给 `dest` 数组的元素。 

### java.util.Arrays类

1. Arrays类中包含了常用的数组操作，方便我们使用。

2. Arrays类包含了：排序、查找、填充、打印内容等常见操作

3. 排序: `Arrays.sort(a)` 

4. 数组引用类型的排序

   ```java
   class Man implements Comparable {
       int age;
       int id;
       String name;
    
       public Man(int age, String name) {
           super();
           this.age = age;
           this.name = name;
       }
    
       public String toString() {
           return this.name;
       }
    
       public int compareTo(Object o) {
           Man man = (Man) o;
           if (this.age < man.age) {
               return -1;
           }
           if (this.age > man.age) {
               return 1;
           }
           return 0;
       }
   }
   ```

   + 主要就是实现了Comparable中的compareTo。
   + 在compareTo中实现了引用类型的排序。

5. 数组的填充：`Arrays.fill(a,2,4,100);` 将2-4索引的元素替换为100；

6.  二分查找: `Arrays.binarySearch(数组名,查找的元素)` 。 

### 多维数组

![image-20200410122136348](C:\Users\张辉\Desktop\日常记录\笔记\Java学校\image-20200410122136348.png)

1. 多维数组可以看成数组为元素的数组。

2. ```java
   int[][] a = new int[3][];
   // a[0] = {1,2,5}; //错误，没有声明类型就初始化
   a[0] = new int[] { 1, 2 };
   a[1] = new int[] { 2, 2 };
   a[2] = new int[] { 2, 2, 3, 4 };
   ```

3. 多为数组在内存中的存储就是这样的（上图）。

4. 我们在开发中一般不使用数组，我们使用容器（collection）。

### 数组存储表格数据

1. ```java
   Object[] a1 = {1001,"高淇",18,"讲师","2006-2-14"};
   Object[] a2 = {1002,"高小七",19,"助教","2007-10-10"};
   Object[] a3 = {1003,"高小琴",20,"班主任","2008-5-5"};
   Object[][]  emps = new Object[3][];
   emps[0] = a1;
   emps[1] = a2;
   emps[2] = a3;
   ```

2. 此处的数据本质不是Object对象。java编译器会自动把基本数据类型“自动装箱”成包装类对象。

## 面向对象基础

### 对象和类的概念

1. 类：我们把类叫做class。类就相当于一个汽车。
2. 对象：我们叫做 `Object,instance(实例)` 。对象就相当于我们通过图纸造出来的汽车。
3. 对象是具体的事物，类是对象的抽象。
4. 类可以看成一类对象的模板，对象可以看成一个类的具体实实例。
5. 类是用于描述同一类型的对象的一个抽象概念，类中定义了这一类对象所应具有的共同的属性、方法。

#### 类的定义

1. 每一个源文件必须且只有一个 `public class` ，并且类名和文件名保持一致。

2. 定义好类之后，里面没有任何信息，是一个空类，没有任何的实际意义。

3. 我们需要定义类的具体信息。对于一个类来说，一般有三种常见成员：属性field、方法methods、构造器constructor。这三种成员可以定义零个或者多个。

4. 例： 

   ```java
   public class SxtStu {
       //属性（成员变量）
       int id;
       String sname;
       int age;  
       //方法
       void study(){
           System.out.println("我正在学习！");
       }  
       //构造方法
      SxtStu(){
      }
   }
   ```

   

#### 属性

1. 属性用于该类或者该对象包含的数据或者静态特征。属性作用范围是整个类体。
2. 在定义成员变量时可以对其进行初始化，如果不对其进行初始化，Java使用默认的值对其初始化。
3. ![image-20200410163008179](C:\Users\张辉\Desktop\日常记录\笔记\Java学校\image-20200410163008179.png)

4. 属性的定义格式： `[修饰符] 属性类型 属性名 = [默认值];` 

#### 方法

1. 格式：

   ```java
   [修饰符] 方法返回值类型 方法名(形参列表) {
       // n条语句
   } 
   ```

2. 如果时类内部用的方法可以直接设置为私有，这样就不会向外暴漏。

#### 定义类示例和UML图

```java
public class Student {
    // 属性fields
    int id;
    String name;
    int age;
    Computer comp;
    void study() {
        System.out.println("我在学习！" + comp.brand);
    }
    void play() {
        System.out.println("我在玩游戏！");
    }
    //构造方法，用于创建这个类的对象，无参的构造方法可以由系统自动创建。
    Student() {
    }

    //程序执行的入口，必须要有
    public static void main(String[] args) {
        Student stu = new Student(); // 创建一个对象
        //这儿创建的对象就是前边的构造方法，用来创建这个类的对象。现时使用中可以省略不写
        stu.id = 1001;
        stu.name = "zhanghui";
        stu.age = 18;
        Computer c1 = new Computer();
        c1.brand = "联想";
        stu.comp = c1;
        stu.study();
        stu.play();
    }
}
class Computer {
    String brand;
}
```

1. 构造方法，用于创建这个类的对象，无参的构造方法可以由系统自动创建。
2. 这儿创建的对象就是前边的构造方法，用来创建这个类的对象。现时使用中可以省略不写。有参的情况下，一般都会写。
3. ![image-20200410164035398](C:\Users\张辉\Desktop\日常记录\笔记\Java学校\image-20200410164035398.png)

### 面向对象的内存分析

1. JVM的内存可以分为三个区域：栈stack、堆heap、方法区method area.
2. 栈（stack）:
   + 栈描述的式方法执行的内存模型。每个方法被调用都会创建一个栈帧（存储局部变量、操作数、方法出口等）
   + JVM为每一个线程创建了一个栈，用于存放该线程执行方法的信息（实际参数、局部参数等）
   + 栈属于私有线程，不能实现线程之间的共享。
   + 栈的存储特性：先进后出，后进先出。
   + 栈式由系统自动分配，速度快，栈式一个连续的内存空间！
3. 堆（heap）：
   + 堆用于存储创建好的对象和数组（数组也是对象）。
   + JVM只有一个堆，所有数据都被线程间共享。
   + 堆是一个不连续的内存空间，分配灵活，速度慢！
4. 方法区（又叫静态区：method area）：
   + JVM 只有一个方法区，被所有的线程共享！
   + 方法区实际也是堆，只适用于存储类、常量等相关信息！
   + 用来存放程序中永远不变或唯一的内容。（类信息【Class对象】、静态变量、字符串常量等）
5. ![Snipaste_2020-04-10_17-26-56](C:\Users\张辉\Desktop\日常记录\笔记\Java学校\Snipaste_2020-04-10_17-26-56.jpg)

### 构造方法（constructor）

1. 构造器也叫构造方法，用于对象的初始化。
2. 通过new关键字调用
3. 构造器虽然有返回值，但是不能定义返回值类型（返回值的类型肯定是奔类），`不能再构造器里使用return 返回某个值`(所以他不能被构造)。
4. 如果我们没有定义构造器，则编译器会自动定义一个无参的构造函数。如果以定义则编译器不会自动添加。
5. 构造器的方法名必须和类名一致。
6. 构造器可以理解为帮助类进行初始化的方法。

#### 构造方法重载

+ 与普通方法一样，构造方法也可以重载。
+ 重载的使用与普通方法的重载一样。

### 垃圾回收机制（GC）

#### 内存管理

1. Java的内存管理很大程度值得就是对象的管理，其中包括对象空间的分配和释放。
2. 对象空间的分配：使用new关键字创建对象即可。
3. 对象空间的释放：将对象赋值null即可。垃圾回收器将负责回收所有“不可达”对象的内存空间。

#### 垃圾回收过程

1. 发现无用的对象。
2. 回收无用对象占用的内存空间。
3. 垃圾回收机制保证可以将“无用的对象”进行回收。无用对象值得就是没有任何变量引用该对象。

#### 垃圾回收算法

1. 引用计数法：

   + 堆中的每个对象都有一个引用计数。被引用一次，计数加1，被引用变量值为null，则计数减1.直到计数为0.

   + 缺点：“循环引用的无用对象”无法识别。

   + ```java
     s1.friend = s2;
     s2.friend = s1;    
     s1 = null;
     s2 = null;
     // s1和s2互相引用对方，导致他们引用计数不为0，但是实际已经无用，但无法被识别。
     ```

2. 引用可达法（根搜索算法）

   + 从开始第一个节点，寻找下一个节点；当所有的引用节点寻找完毕之后，剩余的节点则被认为是没有被引用的节点，即无用的节点。

#### 通用的分代垃圾回收机制

1.  新创建的对象，绝大多数都会存储在Eden中，

2. 当Eden满了（达到一定比例）不能创建新对象，则触发垃圾回收（GC），将无用对象清理掉， 然后剩余对象复制到某个Survivor中，如S1，同时清空Eden区。
3. 当Eden区再次满了，会将S1中的不能清空的对象存到另外一个Survivor中，如S2，同时将Eden区中的不能清空的对象，也复制到S1中，保证Eden和S1，均被清空。
4. 重复多次(默认15次)Survivor中没有被清理的对象，则会复制到老年代Old(Tenured)区中，
5. 当Old区满了，则会触发一个一次完整地垃圾回收（FullGC），之前新生代的垃圾回收称为（minorGC）
6. 三个回收：
   + Minor GC：用于清理年轻代区域。
   + Major GC：用于清理老年代区域。
   + Full GC：用于清理年轻代、年老代。成本较高。
7.  持久代：用于存放静态文件，如Java类、方法等。持久代对垃圾回收没有显著影响。

#### JVM调优和Full GC 

1. JVM 调优的过程中很大一部分是对Full GC 的调节。
2. 导致Full GC 可能有以下原因：
   + 年老代（Tenured）被写满
   + 持久代（Perm）被写满
   + System.gc()被显式调用（程序建议启动GC，不是调用GC）
   + 上一次GC之后heap的各域分配策略动态变化

#### 内存泄漏

1. 创建了大量无用对象：拼接字符串时使用了String会造成。
2. 静态集合类的使用（HashMap,Vector,list）
3. 监视器的使用：释放对象时，没有删除相应的监视器。
4. 各种连接对象未关闭。

### this 关键字

1. this 的本质就是“创建好的对象的地址”！由于在构造方法调用前，对象已经创建。因此在构造方法中也可以使用this代表“当前对象”。
2. this 不能用于 static 方法中（static中对象还没有被创建好）。

### static 关键字

1. 在类中，static 声明的成员变量为静态成员变量。
2. 类变量的生命周期和类相同，在整个应用的执行期间都有效。
3. static 的变量为公用变量，属于类。被该类的所有实例共享，在类被载入时显式的初始化。
4. 一般使用“类名.类属性/方法”来调用。
5. static 方法中不可以直接访问`非static` 的成员。

### 参数传值机制

1. 基本数据类型参数的传值：传递的式值的副本。副本改变不会影响原件。
2. 引用类型参数传值：传递的式值的副本，但是引用类型值得是“对象的地址”。因此，副本和原参数都指向了同一个“地址”，所以说改变了副本的值也会改变原来的值。

### 静态初始化块

> 静态初始化块用于类的初始化操作（初始化时之）！在静态初始化块中不能直接访问static成员

### 静态导入

> 在jdk1.5增加的新功能，其作用是用于导入指定类的静态属性，这样我们就可以直接使用。

## 常用类

### 包装类

![image-20200411213327310](C:\Users\张辉\Desktop\日常记录\笔记\Java学校\image-20200411213327310.png)

#### 包装类的用途

1. 作为和基本类型对应的类型存在，方便涉及到对象的操作。
2. 包含每种基本数据类型的相关属性如最大值，最小值等，以及相关的操作方法。

#### 自动装箱和拆箱

1. 自动装箱
   1. 基本类型的数据处于需要对象的环境中时，会自动转化为“对象”。
   2. `Integer i = 5` 在自动装箱中就相当于 `Integer i = Integer.valueOf(5)` 这样的操作，这就是Java的自动装箱
2. 自动拆箱
   1. 没有必要显式的调用intValue(),doubleValue()等转型方法。
   2. 如： `Integer i = 5;int j = i;` 这样的过程就是自动拆箱。
3. 包装类的空指异常
   1. 当 `Integer i = null;int j = i.intValue();`  这样就会造成空指异常。
   2. 因为 i 并没有指向任何对象的实体，所以就不可能操作 intValue()方法。

#### 包装类的缓存问题

1.  如果数据在-128~127这个区间，那么在类加载时就已经为该区间的每个数值创建了对象，并将这256个对象存放到一个名为cache的数组中。每当自动装箱过程发生时(或者手动调用valueOf()时)，就会先判断数据是否在该区间，如果在则直接获取数组中对应的包装类对象的引用，如果不在该区间，则会通过new调用包装类的构造方法来创建对象。 
2. IntegerCache类为Integer类的一个静态内部类，仅供Integer类使用。
3.  一般情况下 IntegerCache.low为-128，IntegerCache.high为127，IntegerCache.cache为内部类的一个静态属性

### String类

#### String

1. String类对象代表不可变的字符序列，因此我们可以将对象称为“不可变对象”。
2. String 类底层创建的数组是final的，也就是常量，只能被赋值一次。
3. String类常用的方法：
   1. 创建返回对象：concat(),replace(),substring(),toLowerCase(),toUpperCase(),trim(),
   2. 提供查功能：endsWith(),startsWith(),indexOf(),lastIndexOf()
   3. 提供比较功能的方法：equals(),equalsIgnoreCase(),compareTo().
   4. 其他方法：charAt(),length().

#### StringBuffer和StringBuilder

1. StringBuffer 线程安全，做线程同步检查，效率较低。
2. StringBuilder 线程不安全，不做线程同步检查，效率高。
3. 这俩的方法都是返回自己本身。
4.  append(…)  添加字符序列，仍然返回自身对象。 
5.  delete(int start,int end)   删除从start开始到end-1为止的一段字符序列，仍然返回自身对象 
6.  deleteCharAt(int index)    移除此序列指定位置上的 char，仍然返回自身对象 
7.  insert(…)   在指定位置插入字符序列，仍然返回自身对象 
8.  reverse()    用于将字符序列逆序，仍然返回自身对象。 
9.  toString() 返回此序列中数据的字符串表示形式 

### 时间类

>  JDK1.1之后，日期操作一般使用Calendar类，而字符串的转化使用DateFormat类。 

#### DateFormat类和SimpleDateFormat类

![image-20200411220720702](C:\Users\张辉\Desktop\日常记录\笔记\Java学校\image-20200411220720702.png)

```java
// 把时间对象按照"格式字符串指定的格式"转成相应的字符串
DateFormat df = new SimpleDateFormat("yyyy-MM-dd hh:mm:ss");
// SimpleDateFormat是DateFormat的一个子类
String str = df.format(new Date(40000000));
System.out.println(str);

// 把字符串按照“格式字符串指定格式”转成相应的时间对象
DateFormat df2 = new SimpleDateFormat("yyyy年MM月DD日 hh时mm分ss秒");
Date date = df2.parse("2020年04月07日 12时16分40秒");
System.out.println(date);

// 测试其他的格式字符。比如：利用D，获取本事件对象是所处年份的第几天。
DateFormat df3 = new SimpleDateFormat("D");
// SimpleDateFormat是DateFormat的一个子类
String str3 = df3.format(new Date());
System.out.println(str3);
```



#### Calendar日历类

>  GregorianCalendar 是 Calendar 的一个具体子类，提供了世界上大多数国家/地区使用的标准日历系统。 

```java
public static void printCalendar(Calendar c) {
    // 打印：1918年10月10日 11：23：45 周三
    int year = c.get(Calendar.YEAR);
    int month = c.get(Calendar.MONTH) + 1;
    int date = c.get(Calendar.DAY_OF_MONTH);
    int dayweek = c.get(Calendar.DAY_OF_WEEK) - 1;
    String datweek2 = dayweek==0?"日":dayweek+"";

    int hour = c.get(Calendar.HOUR);
    int minute = c.get(Calendar.MINUTE);
    int second = c.get(Calendar.SECOND);

    System.out.println(year + "年" + month + "月" + date + "日" + hour + "时" + minute + "分" + second + "秒" + " 周" + datweek2);
}
```

### Math类

1. abs 绝对值

2. acos,asin,atan,cos,sin,tan 三角函数

3. sqrt 平方根

4. pow(double a, double b) a的b次幂

5. max(double a, double b) 取大值

6. min(double a, double b) 取小值

   7. ceil(double a) 大于a的最小整数

   8. floor(double a) 小于a的最大整数

9. random() 返回 0.0 到 1.0 的随机数
10. long round(double a) double型的数据a转换为long型(四舍五入)

11. toDegrees(double angrad) 弧度->角度

12. toRadians(double angdeg) 角度->弧度
13. java.lang.Math提供类一系列静态方法用于科学计算。

### File类

1.  java.io.File类：代表文件和目录。 在开发中，读取文件、生成文件、删除文件、修改文件的属性时经常会用到本类。 

2.  ```java
   File f = new File("d:/b.txt");
   f.renameTo(new File("D:/b.txt"));
   System.out.println("File是否存在："+f.exists());
   System.out.println("File是否是目录："+f.isDirectory());
   System.out.println("File是否是文件："+f.isFile());
   System.out.println("File最后修改时间："+new Date(f.lastModified()));
   System.out.println("File的大小："+f.length());
   System.out.println("File的文件名："+f.getName());
   System.out.println("File的目录路径："+f.getPath());
   ```

3. 关于文件操作的很多文件都在这个包中

### 枚举

1. 格式： `enum 枚举名 {枚举体（常量列表）}`

2. ```java
   enum` `Season {
     ``SPRING, SUMMER, AUTUMN, WINDER 
   }
   ```

3.  枚举实质上还是类!而每个被枚举的成员实质就是一个枚举类型的实例，他们默认都是public static final修饰的。可以直接通过枚举类型名使用它们。 

## 异常机制

### 异常分类

1. Throwable分为Error和Exception.

#### Error

1. Error是程序无法处理的错误，是JVM出现的问题。
2. 大多数情况下重启虚拟机则可以解决。

#### Exception

1. RuntimeException 运行时异常
2. CheckedException 已检查异常
3. 抛出异常：throw
4. 捕获异常：try-catch

#### RuntimeException

1. 运行时异常包括：被0除，数组下标越界，空指针等。
2. 通常需要增加逻辑处理来避免这些异常。

#### CheckedException

1. 这就是我们在书写程序时遇到的错误。
2. 不处理，就不能通过编译。

#### try-catch-finally

1. 如果出现异常，可以通过catch来捕获异常并处理。
2. 最后一步的finally所指定的代码都要被执行。
3.  即使try和catch块中存在return语句，finally语句也会执行。是在执行完finally语句后再通过return退出。 
4.   finally语句块只有一种情况是不会执行的，那就是在执行finally之前遇到了System.exit(0)结束程序运行。 

####  **throws** 

> 将当前遇到的异常传递给下一层处理。

### 自定义异常

```java
/**IllegalAgeException：非法年龄异常，继承Exception类*/
class IllegalAgeException extends Exception {
    //默认构造器
    public IllegalAgeException() {
     
    }
    //带有详细信息的构造器，信息存储在message中
    public IllegalAgeException(String message) {
        super(message);
    }
}
```

1. 要避免使用异常处理代替错误处理，这样会降低程序的清晰性，并且效率低下。

2. 处理异常不可以代替简单测试---只在异常情况下使用异常机制。

3. 不要进行小粒度的异常处理---应该将整个任务包装在一个try语句块中。

4. 异常往往在高层处理 。

## 面向对象进阶

### 继承（extends）

+ 继承的意思即是对一个内容进行扩展构成一个新的内容。
+ 比如：动物可以继承扩展为哺乳动物和爬行动物；他们的底层都是相同的，但是总有一些不一样的地方。
+ Object类是所有Java类的根基类，也就是所有的Java对象都拥有Object类的属性和方法。

#### instanceof

1. `instanceof` 是二元运算符，左边是对象，右边是类

2. 当对象是右边类或子类所创建的对象时，返回true，否则false.

3. ```java
   // Student类是Person的一个子类
   Student s = new Student("zs",190,"c++");
   System.out.println(s instanceof Person);
   System.out.println(s instanceof Student);
   ```

#### 继承使用应注意的要点

1. 父类也成为超类、基类、派生类等。
2. Java中只有单继承（但是接口可以多继承）。多继承会引起会乱，是的继承链过于复杂，系统难于维护。
3. Java中类没有多继承，接口有多继承。
4. 子类继承父类，可以得到父类所有属性和方法（除了父类的构造方法），但不见得可以直接访问（父类的私有属性和方法）。
5. 在定义类是没有调用 extends ，则他的父类是： java.lang.Object

#### 方法的重写（override）

1. 重写的条件

   + 方法名和形参列表必须相同。
   + 返回值类型和声明异常类型，子类小于等于父类。
   + 访问权限，子类大于等于父类。

2. ```java
   public class TestOverride {
       public static void main(String[] args) {
           Vehicle v1 = new Vehicle();
           Vehicle v2 = new Horse();
           Vehicle v3 = new Plane();
           v1.run();
           v2.run();
           v3.run();
           v2.stop();
           v3.stop();
       }
   }
   class Vehicle { // 交通工具类
       public void run() {
           System.out.println("跑....");
       }
       public void stop() {
           System.out.println("停止不动");
       }
   }
   class Horse extends Vehicle { // 马也是交通工具
       public void run() { // 重写父类方法
           System.out.println("四蹄翻飞，嘚嘚嘚...");
       }
   }
    
   class Plane extends Vehicle {
       public void run() { // 重写父类方法
           System.out.println("天上飞！");
       }
       public void stop() {
           System.out.println("空中不能停，坠毁了！");
       }
   }  
   ```

3. 继承的方法在使用的时候，必须new.

4. new的时候可以使用 ` Vehicle v3 = new Plane(); ` ，但是在后边的对象转型的时候，必须注意（不能转错类型，因为一个父类可能存在多个子类）。

### 一些基础方法（toString,==,equals）

#### toString 

1. Object类中定义了 `public String toString()` 方法，其返回值是String类型的。
2. Object类中的toString方法是输出：类名+@+16进制的hashcode
3. 所以在一般使用中toString 方法一般都会被重写。

#### == 和 equals

1. `==` 海表比较双方是都夏姑娘同。如果是基本类型则表示值相等，如果是引用类型则表示地址相等则为同一个对象。
2. `equals` 方法默认就是比较两个对象的hashcode，是同一个类型的引用时返回true。一般我们会重写equals方法。
3. JDK提供的很多类中都对equals方法进行类重写（重写之后一般都是比较内容值是否相等）。

### super关键字和继承树

1. super时直接父类对象的引用。可以通过super来访问父类中被子类覆盖的方法或属性。
2. 使用super调用普通方法，语句没有位置限制，可以在子类中随便调用。
3. super()方法构造函数都会默认调用。

4. 继承方法使用的时候会向上寻找我们的调用（继承树回溯）。

### 封装

+ 提高代码的安全性
+ 提高代码的复用性
+ “高内聚”：封装细节，便于修改内部代码，提高可维护性。
+ “低耦合”：简化外部调用，便于调用者使用，便于扩展和协作。

#### 访问控制

1. `private ` 表示私有，只有自己类能访问 
   + 只能在自己的类中使用，其他地方都不能使用
   + 使用范围：同一个类（一个类就是一个.java中的一个class）
2. `default` 表示没有修饰符修饰，只有同一个包的类能访问
   + 在变量或者方法没有被修饰的情况下默认为 default 的，这样就最大就只能在同一个包中使用
   + 使用范围：同一个类，同一个包(一个包就是package中)
3. `protected` 表示可以被同一个包的类以及其他包中的子类访问(好像不太经常使用)
   + 在被 protected 修饰的情况下，变量或者方法就最多被继承它的子类所使用。
   + 使用范围：同一个类，同一个包，它的子类(使用 extends 继承了它的子类，这儿的继承也就只能在同一个)
4. `public` 表示可以被该项目的所有包中的所有类访问

#### 封装的细节

1. 一般使用 `private` 访问权限
2. 提供相应的 get/set 方法来访问相关属性，这些方法通常是public的。
3. boolean 变量的 get 方法是 is 开头的。
4.  一些只用于本类的辅助性方法可以用private修饰，希望其他类调用的方法用public修饰。 

### 多态（polymorphism）

1. 多态是方法的多态，不是属性的多态

2. 多态的存在有三个必要条件：继承，方法重写，父类引用指向子类对象。

3. 父类引用指向子类对象后，该父类引用调用子类重写的方法，此时多态就出现了。

4. 简单来说，多态就是多个子类继承同一个父类，然后对父类中的某个方法都进行了重写（override）。这样就构成了多态。

5. ```java
   // 有了多态，只需要让增加的这个类继承Animal类就可以了。
   static void animalCry(Animal a) {
       a.shout();
   }
   ```

6. 不管是什么动物叫，我们只要把对象传进去，就能发出准确的叫声。

### 对象的转型(casting)

1. 父类引用指向子类对象，我们成这个过程为向上转型，属于自动类型转换。
2. 向上转型后的父类引用变量只能调用他编译类型的方法，不能调用它运行时类型的方法。这时，我们就需要强制转型，称之为向下转型。
3. 类型转换时应该注意异常的处理。

### final关键字

1. final修饰的变量不能被二次赋值。
2. final修饰的方法，不能被重写。
3. final修饰的类不能被继承。

### 抽象方法和抽象类（abstract）

#### 抽象方法

+ 使用abstract修饰的方法，没有方法体，只有声明。
+ 定义的是一种规范，告诉子类必须要给抽象方法提供具体的实现。

#### 抽象类

+ 包含抽象方法的类就是抽象类。
+  通过abstract方法定义规范，然后要求子类必须定义具体实现 
+  通过抽象类，我们就可以做到严格限制子类的设计，使子类之间更加通用。 

#### 抽象类使用要求

1. `抽象方法的类只能定义成抽象类。`
2. 抽象类不能实例化，也就是不能用 `new` 来实例化抽象类。
3. 抽象类可以包含属性、方法、构造方法。但是构造方法不能用来 `new` 实例，只能用来被子类调用。
4. 抽象类只能用来被继承。
5. 抽象方法必须被子类实现。

### 接口（interface）

+ 普通类：具体实现
+ 抽象类：具体实现，规范（抽象方法）。
+ 接口：规范

#### 接口的定义

1. 声明格式：

   ```java
   [访问修饰符]  interface 接口名   [extends  父接口1，父接口2…]  {
   常量定义；  
   方法定义；
   }
   ```

2. 访问修饰符：只能时public或者默认（default）。

3. 接口名：和类名采用相同的命名机制；首字母大写和驼峰原则；

4. extends：接口可以多继承，但是 `继承的都是接口` 。

5. 常量：接口中的属性只能是常量，总是 `public static final` 修饰的，不写也是如此。

6. 方法：接口中的方法只能是 `public abstract` ，省略的话也是 `public abstract` ，也就意味着方法是抽象的，只需要规范即可，不需要实现。

#### 接口的使用

1. 子类通过 `implements` 来实现接口中的规范。

2. 接口不能创建实例，但是可用于声明引用变量类型。

3. 一个类实现了接口，必须实现接口中所有的方法，并且这些方法只能是 `public` 的。

4. 在JDK1.8后，接口中包含了静态常量，抽象方法，静态方法。不能有普通属性，构造方法。

5. ```java
   public class TestInterface {
       public static void main(String[] args) {
           Volant volant = new Angel();
           volant.fly();
           System.out.println(Volant.FLY_HIGHT);
            
           Honest honest = new GoodMan();
           honest.helpOther();
       }
   }
   /**飞行接口*/
   interface Volant { 
       int FLY_HIGHT = 100;  // 总是：public static final类型的；
       void fly();   //总是：public abstract void fly();
   }
   /**善良接口*/
   interface Honest { 
       void helpOther();
   }
   /**Angle类实现飞行接口和善良接口*/
   class Angel implements Volant, Honest{
       public void fly() {
           System.out.println("我是天使，飞起来啦！");
       }
       public void helpOther() {
           System.out.println("扶老奶奶过马路！");
       }
   }
   class GoodMan implements Honest {
      public void helpOther() {
           System.out.println("扶老奶奶过马路！");
       }  
   }
   class BirdMan implements Volant {
       public void fly() {
           System.out.println("我是鸟人，正在飞！");
       }
   }
   ```

#### 接口的多继承

```java
interface A {
    void testa();
}
interface B {
    void testb();
}
/**接口可以多继承：接口C继承接口A和B*/
interface C extends A, B {
    void testc();
}
public class Test implements C {
    public void testc() {
    }
    public void testa() {
    }
    public void testb() {
    }
}
```

### 内部类

#### 非静态/静态内部类

```java
public class TestInnerClass {
    public static void main(String[] args) {
        Outer outer = new Outer();
        /**
         * 上边是创建外部类
         * 下边创建内部类
         *
         * 非静态内部类可以直接访问外部类成员，但是外部类不能访问非静态内部类的成员
         * 非静态内部类不能有静态方法、静态属性和静态初始化块。
         * 外部类的静态方法、静态代码块不能访问非静态内部类，包括不能使用非静态内部类定义变量、创建实例。
         */
        
        // 创建非静态内部类
        Outer.Inner inner = new Outer().new Inner();
        inner.show();
        
        // 创建静态内部类，静态内部类不依托于外部类
        Outer2.Inner2 inner = new Outer.Inner2();
    }
}
class Outer {
    private int age = 10;

    public void testOuter() {
        System.out.println("Outer.testOuter");
    }

    class Inner {
        int age = 20;
        public void show() {
            int age = 30;
            System.out.println("外部类的成员变量age:" + Outer.this.age);
            System.out.println("内部类的成员变量age:" + this.age);
            System.out.println("局部变量age:" + age);
        }
    }
    static class Inner2{
    }
}
```

#### 匿名内部类

1. 语法： `new 父类构造器（实参类表）\实现接口 () { 匿名内部类类体 }`

2. 匿名内部类只使用一次。

3. ```java
   public class TestAnnonymousInnerClass {
   
       public static void test01(A a){
           System.out.println("ajd");
           a.aa();
       }
       public static void main(String[] args) {
           TestAnnonymousInnerClass.test01(new A() {
               @Override
               public void aa() {
                   System.out.println("Test");
               }
           });
       }
   }
   interface A{
       void aa();
   }
   ```

### String 基础

>  String类是不可变字符串，方法在之前写了。

#### String常用方法

![image-20200413000210787](C:\Users\张辉\Desktop\日常记录\笔记\Java学校\image-20200413000210787.png)

### 常量池

#### 全局字符串常量池（String Pool）

> 存放的内容是类加载完成后存到String Pool中的，每个VM只有一份，存放的是字符串常量的引用值。

#### class文件常量池（Class Constant Pool）

> class常量池是在编译的时候每个class都有的，在编译阶段存放的是常量（文本字符串、final常量等）和符号的引用。

#### 运行时常量池（Runtime Constant Pool）

>  运行时常量池是在类加载完成之后，将每个class常量池中的符号引用值转存到运行时常量池中，也就是说，每个class都有一个运行时常量池，类在解析之后，将符号引用替换成直接引用，与全局常量池中的引用值保持一致。 

## 容器

### 泛型（Generics）

1. 泛型是JDK1.5之后增加的，它可以给我们建立类型安全的集合。
2. 在使用了泛型的集合中，遍历时不必进行强制类型转换。
3. 泛型的本质就是“数据类型的参数化”。
4. 我们可以把泛型理解为数据类型的一个占位符。

#### 自定义泛型

1. 声明：在类的声明处增加泛型列表，如：<T,E,V>.

2. 泛型的使用 

3.  ```java
   class MyCollection<E> {// E:表示泛型;
       Object[] objs = new Object[5];
    
       public E get(int index) {// E:表示泛型;
           return (E) objs[index];
       }
       public void set(E e, int index) {// E:表示泛型;
           objs[index] = e;
       }
   }
   public class TestGenerics {
       public static void main(String[] args) {
           // 这里的”String”就是实际传入的数据类型；
           MyCollection<String> mc = new MyCollection<String>();
           mc.set("aaa", 0);
           mc.set("bbb", 1);
           String str = mc.get(1); //加了泛型，直接返回String类型，不用强制转换;
           System.out.println(str);
       }
   }
   ```

### Collection接口

+ Collection 表示一组对象，它是集中、收集的意思。
+ Collection 接口的两个子接口是 List 、Set 接口。
+ 由于List 、Set是Collection 的子接口，意味着所有的List、Set的实现类都有下面的方法。
+ ![image-20200414101159884](C:\Users\张辉\Desktop\日常记录\笔记\Java学校\image-20200414101159884.png)

### List 

1. List是`有序`、`可重复`的容器
2. 有序：List 中每个元素都有索引表记。可以根据元素的索引标记（在List中的位置）访问元素，从而精确控制这些元素。
3. 可重复：List 允许加入重复的元素。List 通常允许满足 e1.equals(e2) 的元素重复加入容器。
4. List 不仅继承了 Collection的所有方法，还有以下方法：![image-20200414101714526](C:\Users\张辉\Desktop\日常记录\笔记\Java学校\image-20200414101714526.png)

5. List 有三个实现类： ArrayList，LinkedList和Vector
6. ArrayList：底层使用数组实现的存储。特点：查询效率高，增删效率低，线程不安全。（虽然不安全，但是我们使用它。）
   + 数组扩容是使用： `int newCapacity = oldCapacity + (oldCapacity >> 1) `
7. LinkedList：底层用双链表实现的存储。特点：查询效率低，删除效率高，线程不安全。
8. Vector：底层使用的数组（实现过程都使用ArrayList的实现方法）实现了List，但是相关方法都加了同步检查，因此“线程安全，效率低”。
   + 所有实现都增加了 `synchronized` 

#### 如何选用 ArrayList,LinkedList,Vector

1. 需要线程安全时，用Vector。
2. 不存在线程安全问题时，并且查找较多用ArrayList（一般使用它）。
3. 不存在线程安全问题时，增加或删除元素较多用LinkedList.

### Map接口

1. Map就是用来存储“键(key)-值(value)对”的。
2. Map 类中存储的“键值对”通过键来标识，所以“键对象”不能重复。
3. Map接口的实现类有 HashMap,TreeMap,HashTable,Properties等。
4. Map接口中常用的方法![image-20200414140041796](C:\Users\张辉\Desktop\日常记录\笔记\Java学校\image-20200414140041796.png)

#### HashMap和HashTable

1. HashMap 次啊用哈希算法实现，是Map接口最常用的实现类。
2. HashMap 底层采用了哈希表存储数据，我们要求键不能重复，如果发生重复，新的键值对替换旧的键值对。
3. HashMap继承了ArrayList和LinkedList的优点，在查找、删除、修改方面都有非常高的效率。
4. HashTable类和HashMap用法几乎一样，底层实现几乎一样，只不过HashTablede的添加了 `synchronized` 关键字确保线程同步检查，效率较低。
5. HashMap：线程不安全，效率高。允许key或value为null.
6. HashTable：线程安全，效率低。不允许key或value为null.

#### HashMap底层

1. HashMap底层实现采用了哈希表，这是一种非常重要的数据结构。
2. 数组：占用空间连续。寻址容易，查询速度快。但是，增加和删除效率非常低。
3. 链表：占用空间不连续。寻址困难，拆线呢速度慢。但是，增加和删除效率非常高。
4. HashMap结合了数组和链表的优点（数组+链表）。

5. `resize` 利用扩展因子（ loadFactor ），默认情况下扩展因子为0.75；每当hashmap中的元素个数超过当桶位元素的个数的0.75倍时，就会将数组大小扩大一倍。hashmap的大小是2的倍数。
6. hashmap结构：hash|key|value|next
7. hashcode使用 `value&length-1`
8. 在JDK8中，对应链表长度大于8时，链表就会转换为红黑树，这样大大提高了查找的效率。

## IO流

1. 对于程序设计来说，输入输出（Input/Output）系统是非常核心的功能。
2. 输入（Input）指的是：可以让程序从外部系统获得数据（核心含义是“读”，读取外部数据）。
3. 输出（Output）指的是：将程序获取到的数据输出到外部。

### 文件相关知识

#### 1. 文件的路径

```text
1. 文件的路径一般表示为: "C:/Users/zs/Desktop/th.jpg";
2. 在Windows中文件的路径表示为: "C:\Users\zs\Desktop\th.jpg"
3. 在我们的编译中"\"作为转义字符使用,所以我们一般会用"\\"表示我们的"\".
4. 除过斜杆拼接,我们在Java中还有"File.separator"可以作为拼接常量,供我们使用.
```

#### 2. 构建文件对象

 ```java
String path = "C:/Users/zs/Desktop/th.jpg";
File src = new File(path); 
// 通过字符串对象的路径构建File对象
src = new File("C:/Users/zs/Desktop/th.jpg");
// 直接通过字符串的路径构建File对象
src = new File(new File("C:/Users/zs/Desktop/"),"th.jpg");
// 首先确定要构造文件目录的对象,然后再确定相对应的文件.

 ```

#### 3. 相对路径与绝对路径

```java
// 从文件根路径开始的路径就是绝对路径
// 不是从文件根路径开始的路径就是相对路径
File src = new File(path);
src.getAbsolutePath();
// 获取文件的绝对路径
System.getProperty("user.dir");
// 获取项目的相对路径
```

#### 4. 获取文件的名称和路径

```java
src.getName(); //获取文件的名称
src.getPath(); //获取文件的路径
src.getAbsolutePath(); //获取文件的绝对路径
src.getParent(); //获取文件的父节点
src.getParentFile(); //获取文件的父对象 
```

#### 5. 获取文件的状态

```java
src.exists(); // 判断文件是否存在
src.isFile(); // 判断是否文件
src.isDirectory(); //判断是否文件夹

// 文件状态判断的完整操作
src = new File("xxx");
if (src == null || !src.exists()) {
    // 文件不存在
} else {
    if (src.isFile()) {
        // 文件操作
    } else {
        // 文件夹操作
    }
}
```

#### 6. 文件的长度

```java
src.length(); // 获取文件的长度(大小)
// 注意:只能获取文件的长度,不能获取整个文件夹的大小
```

#### 7. 创建/删除文件

```java
File src = new File("C:/Users/zs/Desktop/th.txt");
boolean flag = src.createNewFile();
// 创建文件,不存在才创建,创建成功返回true
flag = src.delete();
// 删除文件,删除成功,返回true
// 再创建文件时要注意:con con3... 操作系统的设备名,不能正确的创建.
```

#### 8. 创建文件夹

```java
// 1. mkdir():确保上级目录存在,不存在创建失败
// 2. mkdirs():上级目录可以不存在,不存在创建失败
// 都是通过返回boolean值来表示文件夹是否创建成功
File dir = new File("F:/IDEA_project/Java300/dir/test");
boolean flag = dir.mkdirs();
flag = dir.mkdir();
```

#### 9. 列出目录的下一级

```java
// list():列出下级名称
// listFiles():列出下级File对象,这儿可以得到下一级文件夹/文件的对象
String[] subNames = dir.list();
File[] subFiles = dir.listFiles();
```

#### 10. 文件的解码/编码

```java
// decode 解码 :  字节数组-->字符串
msg = new String(dates,0,datas.length,"UTF-8");
// encode 编码 :  字符串-->字节数组
byte[] datas = msg.getBytes();
```

#### 11. 乱码

1. 字节数不够:在使用 `new String(dates,0,datas.length,"UTF-8")` 解码的时候 `date.length-1` 长度缺失
2. 字符集不统一:使用的编码字符集不同,就会造成这种问题: `UTF-8或者GBK字符集`

### 数据源(data source)

1. 数据源分为：源设备、目标设备。
2. 源设备(src)：为程序提供数据，一般对应输入流。
3. 目标设备(dest)：程序数据的目的地，一般对应输出流。

### 流(stream)

1. 流是一个抽象、动态的概念，是一连串连续动态的数据集合。
2. 输入流：我们通过流(Stream)将数据源(Source)中的数据(information)输送到程序(program)中。
3. 输出流：目标数据就是目的地(dest)，我们通过流(Stream)将程序(Program)中的数据(information)输送到目的数据源(dest)中。
4. 输入流/输出流的划分并不是相对数据源的，是相对程序而言的。

### IO标准步骤

1. 创建源
2. 选择流
3. 操作
4. 释放资源（先打开的后释放）
5. 标准代码

```java
import java.io.*;
/**
 * 这是输入流
 * @auther 张辉
 */
public class IOStreamStandard{
    public static void main(String[] args) {
        // 1. 创建源
        File src = new File("abc.txt");
        // 2. 选择流
        Reader reader = null;
        try {
            reader = new FileReader(src);
            
            // 3. 操作（读取）
            char[] flush = new char[1024];
            // 缓冲容器
            int len = -1;
            // 接收长度
            while ((len = reader.read(flush)) != -1) {
                // 字符数组到字符串
                String str = new String(flush, 0, len);
                System.out.println(str);
            }
        } catch (FileNotFoyundException e) {
            e.printStackTrace();  
        } catch (IOException e) {
            e.printStackTrace();
        } finally {
            // 4. 释放资源
            try {
                if (reader != null) {
                    reader.close();
                }
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }
}
```

### Java中流的概念细分

#### 按流的方向分类

1. 输入流：数据流向是数据源到程序（以InputStream、Reader结尾的流）。
2. 输出流：数据流向是程序到目的地（以OutputStream、Write结尾的流）。

#### 按处理的数据单元分类

1. 字节流：以字节为单位获取数据，命名以上Stream结尾的流一般是字节流，如：FileInputStream、FileOutputStream。
2. 字符流：以字符为单位获取数据，命名上以Reader/Writer结尾的流一般是字符流，如：FileReader、FileWriter。

#### 按处理对象不同分类

1. 节点流：可以直接从数据源或目的地读写数据，如：FileInputStream、FileReader、DataInputStream等。
2. 处理流：不直接连接到数据源或目的地，是”处理流的流“。通过对其他流的处理提高程序的性能，如BufferedInputStream、BufferedReader等。处理流也叫包装流。
3. 节点流初于IO操作的第一线，所有操作必须通过他们进行；处理流可以对节点进行包装，提高性或提高程序的灵活性。

![image-20200505155826673](C:\Users\张辉\Desktop\日常记录\笔记\Java学校\image-20200505155826673.png)

### Java中IO流类的体系

1.  `InputStream/OutputStream` : 字节流的抽象类
2.  `Reader/Writer` :字符流的抽象类
3.  `FileInputStream/FileOutputStream` 
   + 节点流 : 以字节为单位直接操作"文件".
4.  `ByteArrayInputStream/ByteArrayOutputStream` 
   + 节点流 : 以字节为单位直接操作"字节数组对象".
5.  `FileReader/FileWriter`
   + 节点流 : 以字符为单位直接操作"文本文件" (注意 : 只能读写文本文件).
6.  `ObjectInputStream/ObjectOutputStream`
   + 处理流 : 以字节为单位直接操作"对象".
7.  `DataInputStream/DataOutputStream`
    + 处理流 : 以字节为单位直接操作"基本类型与字符串类型".
8.   `BufferedReader/BufferedWriter`
    + 处理流 : 将 `Reader/Writer` 对象进行包装,增加缓存功能 ,提高读写效率.
9.   `BufferedInputStream/BufferedOutputStream`
    + 处理流 : 将 `InputStream/OutputStream` 对象进行包装,增加缓存功能(一般缓存8k),提高读写效率.
10.   `InputStreamReader/OutputStreamWriter`
     + 处理流 : 将字节对象转化成字符流对象.
11.   `PrintStream`
     + 处理流 : 将 `OUtputStream` 进行包装,可以方便地输出字符,更加灵活.

### 四大IO抽象类

> `InputStream/OutputStream和Reader/Writer` 类是所有IO流类的抽象父类.

#### InputStream

1. 此抽象类是标识字节输入流的所有类的父类.
2. `InputStream` 是一个抽象类,他不可以实例化.
3. 继承自 `InputStream` 的流都是用于向程序中输入数据,且数据的单位为字节(8 bit).
4. 常用方法:
   + int read() : 读取一个字节的数据,并将字节的值作为int类型返回(0-255之间的一个值).如果未读出字节则返回 -1 (返回值为 -1 表示读取结束)
   + void close() : 关闭输入流对象,释放相关系统资源.

#### OutputStream

1. 此抽象类是表示字节输出流的多有类的父类.
2. 输出流接收输出字节并将这些字节发送到某个和目的地.
3. 常用方法:
   + void writer(int n) : 向目的中写入一个字节.
   + void close() : 关闭输出流对象,释放相关资源.

#### Reader

1. Reader用于读取的字符流抽象类,数据单位为字符.
2. int read() : 读取一个字符的数据,并将字符的值作为int类型返回(0-65535之间的一个值,即 Unicode 值).如果未读出字符则返回 -1 (返回值为 -1 表示读取结束)
3. void close() : 关闭流对象,释放相关资源.

#### Writer

1. Writer用于写入的字符流抽象类,数据单位为字符.
2. void writer(int n) : 向输出流中写入一个字符.
3. void close() : 关闭输出流对象,释放相关资源.

### 文件字节流

1. `InputStream/OutputStream` 
2. 为了减少对硬盘的读写次数,提高效率,通常设置缓存数组.相应地,读取时使用的方法为: `read(byte[] b)` ;写入时方法为: `write(byte[] b,int off,int length)`
3. 程序中如果遇到多个流,每个流都要单独关闭,防止防止其中一个流出现异常后导致其他流无法关闭的情况.
4. 在关闭多个流的时候,先打开的后关闭.

#### 文件字节输入流

> `InputStream/FileInputStream` 文件字节输入流 

```java
import java.io.*;

public class InputStreamZh{
    public static void main(String[] args) {
        // 1. 创建源
        File src = new File("abc.txt");
        // 2. 选择流
        InputStream is = null;
        try {
            is = new FileInputStream(src);
            // 3. 操作(读取)
            byte[] flush = new byte[1024];
            // 缓冲容器
            int len = -1;
            // 接收长度
            while ((len = is.read(flush)) != -1) {
                String str = new String(flush,0,len);
                System.out.println(str);
            }
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        } catch (IOException e) {
            e.printStackTrace();
        } finally {
            // 4. 释放资源(字节输入流可以不用释放,GC会帮我们处理,但是最好还是自己来关闭流,因为GC的回收是不确定的)
            try {
                if (is != null) {
                    is.close();
                }
            } catch (IOExcrption) {
                e.printStackTrace();
            }
        }
    }
}
```

#### 文件字节输出流

> `OutputStream/FileOutputStream` 文件字节输出流(在输出流中都需要 `flush()` ),使用 `byte[]`

```java
import java.io.*;

public class OutputStreamZh{
    public static void main(args) {
        // 1. 创建源
        File dest = new File("dest.txt");
        // 2. 选择流
        OutputStream os = null;
        try {
            os = new FileOutputStream(dest,true);
            // 这儿的true,决定了文件是覆盖写入还是append.
            // 3. 操作
            String msg = "I am groot";
            byte[] datas = msg.getBytes();
            os.write(datas,0,datas.length);
            os.flush();
            // 刷新,防止文件内容驻留
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        } catch (IOException e) {
            e.printStackTrace();
        } finally {
            // 4. 释放资源
            try {
                if (os != null) {
                    os.close();
                }
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }
}
```

#### 文件字节拷贝流

> 利用文件字节流实现文件的复制

```java
import java.io.*;

/**
 * @auther 张辉
 * @Description 文件字节流复制的类
 */
public class CopyUtilsByte {
    private File src;
    private File dest;
    private int size = 1024 * 10;
    
    public CopyUtilsByte(String src, String dest) {
        this.src = new File(src);
        this.dest = new File(dest);
    }

    public CopyUtilsByte(String src, String dest, int size) {
        this.src = new File(src);
        this.dest = new File(dest);
        this.size = size;
    }

    public CopyUtilsByte(File src, File dest) {
        this.src = src;
        this.dest = dest;
    }

    public CopyUtilsByte(File src, File dest, int size) {
        this.src = src;
        this.dest = dest;
        this.size = size;
    }
    
    private void copy() {
        try (InputStream is = new FileInputStream(src);
             OutputStream os = new FileOutputStream(dest);) {
            byte[] flush = new byte[this.size];
            int len = -1;
            while ((len = is.read(flush)) != -1) {
                os.write(flush,0,len);
            }
            os.flush();
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}
```

### 文件字符流

>  文件字节流可以处理所有的文件，但是字节流不能很好的处理Unicode字符，经常会出现“乱码”现象。所以，我们处理文本文件，一般可以使用文件字符流，它以字符为单位进行操作。 

#### 文件字符输入流

> `Reader/FileReader`

```java
import java.io.*;
public class ReaderZh {
    public static void main(String[] args) {
        File src = new File("abc.txt");
        Reader reader = null;
        try (){
            reader = new FileReader(src);
            
            char[] flush = new char[1024];
            int len = -1;
            while((len = reader.read(flush)) != -1) {
                System.out.println(new String(flush,0,len));
            }
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        } catch (IOException e) {
            e.printStackTrace();
        } finally {
            try {
                if (reader != null) {
                    reader.close();
                }
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }
}
```

#### 文件字符输出流

> `Writer/FileWriter`

```java
import java.io.*
public class WriterZh {
    public static void main(String[] args) {
        File dest = new File("dest.txt");
        Writer writer = null;
        try {
            writer = new FileWriter(dest);
            // 写法一
            //String msg = "I am anglue\t嘀哒哒";
            //char[] datas = msg.toCharArray();
            // 字符串到字符数组（编码）
            //writer.write(datas,0,datas.length);
            //writer.flush();

            // 写法二
            //String msg = "I am anglue\t嘀哒哒";
            //writer.write(msg,0,msg.length());
            //weiter.write("~~~~~~~~~");
            //writer.flush();

            // 写法三
            writer.append("I am anglue\\t").append("嘀哒哒~~~~~~~~~~~~");
            writer.flush();

        }catch (FileNotFoundException e) {
            e.printStackTrace();
        } catch (IOException e) {
            e.printStackTrace();
        } finally {
            try {
                if (writer!=null) {
                    writer.close();
                }
            } catch (IOException e) {
                e.printStackTrace();
            }

        }
    }
}

```

#### 文件字符拷贝流

> 利用文件字符流实现文件的拷贝

```java
import java.io.*;

/**
 * @auther 张辉
 * @Description 文件字符流复制的类
 */
public class CopyUtilsChar {
    private File src;
    private File dest;
    private int size = 1024;

    public CopyUtilsChar(String src, String dest) {
        this.src = new File(src);
        this.dest = new File(dest);
        Math s;
    }

    public CopyUtilsChar(String src, String dest, int size) {
        this.src = new File(src);
        this.dest = new File(dest);
        this.size = size;
    }

    public CopyUtilsChar(File src, File dest) {
        this.src = src;
        this.dest = dest;
    }

    public CopyUtilsChar(File src, File dest, int size) {
        this.src = src;
        this.dest = dest;
        this.size = size;
    }

    private void copy() {
        try (Reader reader = new FileReader(src);
             Writer writer = new FileWriter(dest)) {
            char[] flush = new char[size];
            int len = -1;
            while ((len = reader.read(flush)) != -1) {
                writer.write(flush, 0, len);
            }
            writer.flush();
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}
```

### 字节数组流

> `ByteArrayInputStream/ByteArrayOutputStream` 经常用在需要流和数组之间转化的情况。用人话说：FileInputStream是把文件当作数据源。ByteArrayInputStream则是把内存中的“某个字节数组对象”当作数据源。这个数据源是存在内存中的，所以不能太大。这两个流是新增的方法，不要使用InputStream. 字符数组流不用关闭，（GC会自动处理，如果你提出了关闭，也只是一个建议。）

#### 字节数组输入流

> `ByteArrayInputStream`

```java
import java.io.*;
public class ByteArrayInputStreamZh {
    public static void main(String[] args) {
        byte[] src = "I am groot".getBytes();
        ByteArrayInputStream bais = null;
        try {
            bai = new ByteArrayInputStream(src);
            byte[] flush = new byte[16];
            int len = -1;
            while ((len = bais.read(flush)) != -1) {
                System.out.println(new String(flush, 0, len));
            }
        } catch (IOException e) {
            e.printStackTrace();
        } finally {
            try {
                if (bai != null) {
                    bais.close();
                }
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }
}
```

#### 字节数组输出流

> `ByteArrayOutputStream`

```java
import java.io.*;
public class ByteArrayOutputStreamZh {
    public static void main(String[] args) {
        // 这是输出
        byte[] dest = null;
        // 选择流
        ByteArrayOutputStream baos = null;
        try {
            baos = new ByteArrayOutputStream();
            String msg = "I am groot";
            // 数据源
            byte[] datas = msg.getBytes();
            baos.write(datas,0,datas.length);
            baos.flush();
            
            dest = baos.toByteArray();
            System.out.println(new String(dest,0,baos.size()));
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        } cathc (Exception e) {
            e.printStackTrace();
        } finally {
            try {
                if (baos != null) {
                    baos.close();
                }
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }
}
```

#### 字节数组拷贝文件

```java
import java.io.*;
public class IOTest09 {
    public static void main(String[] args) {
        byte[] datas = fileToByteArray("01.png");
        System.out.println(datas.length);
        byteArrayToFile(datas,"02.png");
    }

    /**
     * 1. 图片读取到字节数组
     * 1.1 图片到程序 FileInputStream
     * 1.2 程序到字节数组 ByteArrayOutputStream
     * @param filePath
     * @return byte[]
     */
    public static byte[] fileToByteArray(String filePath){
        // 1. 创建源与目的地
        File src = new File(filePath);
        byte[] dest = null;
        // 2. 选择流
        InputStream is = null;
        ByteArrayOutputStream baos = null;
        try {
            is = new FileInputStream(src);
            baos = new ByteArrayOutputStream();

            // 3. 操作（读取）
            byte[] flush = new byte[1024*10];
            // 缓冲容器
            int len = -1;
            // 接收长度
            while ((len = is.read(flush)) != -1) {
                baos.write(flush, 0, len);
                // 写出到字节数组中
            }
            baos.flush();
            // 刷新，放置驻留
            return baos.toByteArray();
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        } catch (IOException e) {
            e.printStackTrace();
        } finally {
            // 4. 释放资源
            try {
                if (baos != null) {
                    baos.close();
                }
            } catch (IOException e) {
                e.printStackTrace();
            }
            try {
                if (is != null) {
                    is.close();
                }
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
        return null;
    }

    /**
     * 2. 字节数组写出到文件
     * 2.1 字节数组写出到程序 ByteArrayInputStream
     * 2.2 程序写出到文件 FileOutputStream
     * @param src
     * @param filePath
     */
    public static void byteArrayToFile(byte[] src,String filePath){
        // 1. 输出源
        File dest = new File(filePath);
        // 2. 选择流
        InputStream is = null;
        OutputStream os = null;
        try {
            is = new ByteArrayInputStream(src);
            os = new FileOutputStream(dest);
            // 3. 操作（读取）
            byte[] flush = new byte[5];
            // 缓冲容器
            int len = -1;
            // 接收长度
            while ((len = is.read(flush)) != -1) {
                os.write(flush,0,len);
                os.flush();
            }


        } catch (IOException e) {
            e.printStackTrace();
        } finally {
            // 4. 释放资源
            try {
                if (os!=null) {
                    os.close();
                }
            } catch (IOException e) {
                e.printStackTrace();
            }
            try {
                if (is != null) {
                    is.close();
                }
            } catch (IOException e) {
                e.printStackTrace();
            }
        }

    }
}
```

### 缓冲字节流

1. `BufferedInputStream/BufferedOutputStream` ，缓冲流用人话来说：就是在字节流/字符流的外边套一个缓冲区，不必每个都输出, 因此缓冲流是一种处理流(包装流)。 
2.  在关闭流时，应该先关闭最外层的包装流，即“后开的先关闭” 
3.  缓存区的大小默认是8192字节(8K)，也可以使用其它的构造方法自己指定大小。 
4. 主要是缓冲流可以提高IO操作时的性能。

```java
import java.io.*;
public class Buffered{
    public void copy(String strPath, String destPath) {
        // 1. 创建流
        File src = new File(strPath);
        // 源头
        File dest = new File(destPath);
        // 目的地

        // 2. 选择流

        try (InputStream is = new BufferedInputStream((new FileInputStream(src)));
             OutputStream os = new BufferedOutputStream(new FileOutputStream(dest))) {

            // 3. 操作
            byte[] flush = new byte[1024];
            // 缓冲容器
            int len = -1;
            // 接受长度：当输入流到了末尾是，会返回-1
            while ((len = is.read(flush)) != -1) {
                // 上边分段读取
                // 下边分段写入
                os.write(flush, 0, len);
            }
            os.flush();
            // 刷新，放置驻留
        } catch (IOException e) {
            e.printStackTrace();
        }

    }
}
```

### 缓冲字符流

1. `BufferedReader/BufferedWriter` 
2.  BufferedReader/BufferedWriter增加了缓存机制，大大提高了读写文本文件的效率，
3. 同时，提供了更方便的按行读取的方法：readLine(); 处理文本时，我们一般可以使用缓冲字符流。 
4.  readLine()方法是BufferedReader特有的方法，可以对文本文件进行更加方便的读取操作。 
5.  `写入`一行后要记得使用newLine()方法换行。 

```java
import java.io.*;

/**
 * @author 张辉
 * @Description 纯文本拷贝
 * @create 2020-04-26 20:29
 */
public class CopyTxt {
    public static void main(String[] args) {
        copyTxt("abc.txt","dest.txt");
    }

    public static void copyTxt(String strPath,String destPath){
        // 1. 创建流
        File src = new File(strPath);
        //源头
        File dest = new File(destPath);
        // 目的地

        // 2. 选择流

        try (BufferedReader br = new BufferedReader((new FileReader(src)));
             BufferedWriter bw = new BufferedWriter(new FileWriter(dest))) {

            String line = null;

            // 接受长度：当输入流到了末尾是，会返回-1
            while ((line = br.readLine())!=null) {
                bw.write(line);
                // 逐行写出
                bw.newLine();
            }
            bw.flush();
            // 刷新，放置驻留
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}
```

### 数据流

1. 数据流将“基本数据类型与字符串类型”作为数据源，从而允许程序以与机器无关的方式从底层输入输出流中操作Java基本数据类型与字符串类型。
2. `DataInputStream/DataOutputStream` 是处理流，可以对其他节点流或处理流进行包装，增加一些更灵活、更高效的功能。
3. `DataInputStream/DataOutputStream` 提供了可以存取与机器无关的所有Java基础类型数据（如：int、double、String等）的方法。
4. 数据流的写入和读出顺序必须相同

```java
import jva.io.*;
public class DataZh{
    public static void main(String[] args) throws IOException {
        // 写出
        ByteArrayOutputStream baos = new ByteArrayOutputStream();
        // 字节数组流不用关闭。（GC会自动处理，如果你提出了关闭的指令，也只是提出一个建议而已）
        DataOutputStream dos = new DataOutputStream(new BufferedOutputStream(boas));
        dos.writerUTF("这是String串！");
        dos.writerInt(18);
        dos.writerBoolean(true);
        dos.writerChar('a');
        dos.flush();
        // 只要是OutputStream/Writer都必须flush()，防止数据驻留
        
        byte[] datas = baos.toByteArray();
        System.out.println(datas.length);
        
        // 读取
        DataInputStream dis = new DataInputStream(new BufferedInputStream(new ByteArrayInputStream(datas)));
        String msg = dis.readUTF();
        int age = dis.readInt();
        boolean flag = dis.readBoolean();
        char ch = dis.readChar();
        // 在这儿关闭流，先打开的后关闭
    }
}
```

### 对象流

1. 对象流在处理的时候，如果是自己写的类必须有`Serializable` ，又序列化标志的才能处理。
2. 对象流就是对对象进行读写操作的，`ObjectInputStream/ObjectOutputStream`。
3. `ObjectInputStream/ObjectOutputStream`是以“对象”未数据源，但是必须将传输的对象进行序列化与反序列化操作。
4. 并不是所有对象都可以序列化；要序列化必须 `implements java.io.Serializable`

```java
import java.io.*;
import java.util.Date;
public class ObjectZh{
    public static void main(String[] args) throws IOException,ClassNotFoundException{
        // 写出（序列化：serialization）
        ByteArrayOutputStream baos = new ByteArrayOutputStream();
        // 字节数组流可以不用关闭。（GC会自动处理，如果你提出了关闭的要求，也只是一个建议，建议总是好的）
        ObjectOutputStream oos = new ObjectOutputStream(new BufferedOutputStream(baos));
        oos.writerUTF("这是一个字符串！");
        oos.writerInt(18);
        oos.writerBoolean(false);
        oos.writerChar('a');
        
        // 对象
        oos.writerObject("这是一个对象，也是一个串，串也是对象!");
        oos.writerObject(new Date());
        
        Employee emp = new Employee("zhangsan",40000);
        oos.writerObject(emp);
        oos.flush;
        
        byte[] datas = new baos.toByteArray();
        System.out.println(datas.length);
        
        // 读取（反序列化：deserialization）
        ObjectInputStream ois = new ObjectInputStream(new BufferedInputStream(new ByteArrayInputStream(datas)));
        // 写出与读取的顺序必须一致
        String msg = ois.readUTF();
        int age = ois.readInt();
        boolean flag = ois.readBoolean();
        char ch = ois.readChar();
        Object str = ois.readObject();
        Object date = ois.readObject();
        Object employee = ois.readObject();
        
        if (str instanceof String) {
            String strObj = (String)str;
            System.out.println(strObj);
        }
        
        if (date instanceof Date) {
            Date dateObj = (Date)str;
            System.out.println(dateObj);
        }
        
        if (employee instanceof Employee) {
            String empObj = (Employee)employee;
            System.out.println(empObj.getName() + "-->" + empObj.getSalary());
        }
        
    }
}
class Employee implements java.io.Serializable{
    private transient String name;
    // 加了transient的数据，则该数据不需要序列化
    private double salary;

    public Employee(){

    }

    public Employee(String name, double salary) {
        this.name = name;
        this.salary = salary;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public double getSalary() {
        return salary;
    }

    public void setSalary(double salary) {
        this.salary = salary;
    }
}
```

### 序列化(Serializable)

1. 序列化就是将对象转换为字节序列的过程。
2. 序列化：把Java对象转换为字节序列的过程；
3. 反序列化：把字节序列恢复为Java对象的过程。
4. 对象序列化的作用：
   1. 持久化：把对象的字节序列永久地保存到硬盘上，通常存放在一个文件中，比如：休眠地实现；以后服务器session管理，hibernate将对象持久化实现。
   2. 网络通信：在网络上传送对象的字节序列。比如：服务器之间的数据通信、对象传递。

#### 序列化涉及的类和接口

1. ObjectOutputStream代表对象输出流，它的writeObject(Object obj) 方法可对参数指定的obj对象进行序列化，把得到的字节序列写到一个目标流中。
2. ObjectInputStream代表对象输入流，他的readObject()方法从一个源输入流中读取字节序列，再把它们反序列化为一个对象，并将其返回。
3. 只有实现了Serializable接口的类的对象才能被序列化。Serializable接口是一个空接口，只起到标记的作用。

### 转换流

1. `InputStreamReader/OutputStreamWriter` 用来将字节流转化成字符流。
2. 如：`System.in/System.out` 都是字节流对象，但是在我们的实际使用中就需要转换成字符流，所以我们就可以使用 `InputStreamReader/OutputStreamWriter` 来将字节流转化为字符流。

```java
import java.io.*;
public class Covert{
    public static void main(String[] args) {
        try (BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));
             BufferedWriter writer = new BufferedWriter(new OutputStreamWriter(System.out));) {
            String msg = "";
            while (!msg.equals("exit")) {
                msg = reader.readLine();
                writer.write(msg);
                writer.newLine();
                writer.flush();
            }
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}
```

3. 也可以操作网络流来下载网络字节流，并且保存成字符。

```java
public static void main(String[] args) {
    // 操作网络流 下载百度的源代码
    try (BufferedReader reader =
                 new BufferedReader(
                         new InputStreamReader(
                                 new URL("http://www.baidu.com").openStream(),"UTF-8"));
         BufferedWriter writer =
                 new BufferedWriter(
                         new OutputStreamWriter(
                                 new FileOutputStream("beidu.html"),"UTF-8"));) {
        String msg = "";
        while ((msg = reader.readLine()) != null) {
            //System.out.println(msg);
            writer.write(msg);
            // 出现乱码，字符集不统一
            writer.newLine();
        }
        writer.flush();
    } catch (IOException e) {
        e.printStackTrace();
    }
}
```

### 装饰器

1. 装饰器就是将一个功能更加强化。
2.  它可以实现对原有类的包装和装饰，使新的类具有更强的功能。 
3. 在IO流中大量使用了装饰器模式，让流具有更强的功能、更强的灵活性。
4. 用BufferedInputStream装饰了原有的FileInputStream，让普通的FileInputStream也具备了缓存功能，提高了效率。
5. 装饰器就是将原来的方法每继承一次重写一次或者重新写一个新的方法（这个方法继承父类的某个方法），使得子类的功能更加niubi.

### Apache

1. Apache-commons工具包提供了IOUtils/FileUtils，可以让我们非常的对文件和目录进行操作。
2. `IOUtils/FileUtils` 是我们上面IO文件和目录操作的封装。
3. Apache 软件基金会（Apache Software Foundation，简称ASF），官网地址：[www.apache.org](www.apache.org)
4. Apache由很多开源项目：commons,maven,hadoop。
5. [apache commons工具类简介]( https://www.iteye.com/blog/825635381-2230580 )

#### FileUtils类

```txt
cleanFirectory: 清空目录，但不删除目录。
contentEquals: 比较来给两个文件的内容是否相同
copyDirectory: 将一个目录内容拷贝到另一个目录。可以通过FileFilter过滤需要拷贝的文件.
copyFile：将一个文件拷贝到一个新的地址。
copyFileToDirectory：将一个文件拷贝到某个目录下。
copyInputStreamToFile：将一个输入流中的内容拷贝到某个文件。
deleteDirectory：删除目录。
deleteQuietly：删除文件。
listFiles：列出指定目录下的所有文件。
openInputSteam：打开指定文件的输入流。
readFileToString：将文件内容作为字符串返回。
readLines：将文件内容按行返回到一个字符串数组中。
sizeOf：返回文件或目录的大小。
write：将字符串内容直接写到文件中。
writeByteArrayToFile:将字节数组内容写到文件中。
writeLines：将容器中的元素的toString方法返回的内容依次写入文件中。
writeStringToFile：将字符串内容写到文件中。
```

```java
public class CFileUtils {
    public static void main(String[] args) throws IOException {
        // 写出文件
        FileUtils.write(new File("happy.txt"),"danfkdsnafs\r\n","UTF-8",true);
        FileUtils.writeStringToFile(new File("happy.txt"),"danfkdsnafs","UTF-8",true);
        FileUtils.writeByteArrayToFile(new File("happy.txt"),"danfkdsnafs学习".getBytes(),true);

        // 写出文件
        List<String> datas = new ArrayList<String>();
        datas.add("码云");
        datas.add("马化腾");
        datas.add("弼马温");

        FileUtils.writeLines(new File("happy.txt"),datas,"-_______",true);
        // 拷贝URL内容
        String URL = "https://img.zcool.cn/community/0128be58d20fc3a801219c77e6ff8e.jpg@1280w_1l_2o_100sh.jpg";
        FileUtils.copyURLToFile(new URL(URL),new File("marvel.jpg"));
    }
}
```

#### IOUtils类

```txt
buffer方法：将传入的流进行包装，变成缓冲流。并可以通过参数指定缓冲大小。
closeQueitly方法：关闭流。
contentEquals方法：比较两个流中的内容是否一致。
copy方法：将输入流中的内容拷贝到输出流中，并可以指定字符编码。
copyLarge方法：将输入流中的内容拷贝到输出流中，适合大于2G内容的拷贝。
lineIterator方法：返回可以迭代每一行内容的迭代器。
read方法：将输入流中的部分内容读入到字节数组中。
readFully方法：将输入流中的所有内容读入到字节数组中。
readLine方法：读入输入流内容中的一行。
toBufferedInputStream，toBufferedReader：将输入转为带缓存的输入流。
toByteArray，toCharArray：将输入流的内容转为字节数组、字符数组。
toString：将输入流或数组中的内容转化为字符串。
write方法：向流里面写入内容。
writeLine方法：向流里面写入一行内容。
```

```java
public class CIOUtils {
    public static void main(String[] args) throws IOException {

        //读取URL内容到字符串（百度是UTF-8，163是GBK）
        String datas = IOUtils.toString(new URL("https://www.163.com"),"GBK");
        System.out.println(datas);
    }
}
```

### Java中构建jar包

> File --> Project Structure --> Dependencies --> 添加相应的jar包然后Apply

## 线程（Thread）

**多线程：**

多线程使Java语言的重要特性，大量应用于网络编程、服务器端程序的开发，最常见的UI界面底层原理、操作系统底层原理都大量使用了多线程。

**程序：**

“程序（Program）”是一个静态的概念，一般对应与操作系统中的一个可执行文件，比如：我们要启动网易音乐，则对应酷狗的可执行程序。当我们双击网易，则加载到内存中，开始执行该程序，于时产生了“进程”。

**进程：**

1. 执行中的程序叫做进程（Process），是一个动态的概念。现代的操作系统都可以同时启动多个进程。比如同时启动多个应用程序。
2. 进程的特点：
   1. 进程是程序的一次动态执行过程，占用特定的地址空间。
   2. 每个进程由3部分组成：Cpu、data、code。每个进程都是独立的，保有自己的Cpu时间，代码和数据，即便用同一份程序产生好几个进程，他们之间还是拥有自己的这三样东西，这样的缺点是：浪费内存，CPU的负担较重。
   3. 多任务（Multitasking）操作系统将CPU时间动态规划地分给某个进程，操作系统同时执行多个进程，你每个进程独立的运行。以进程的观点来看，它会以自己独占CPU的使用权。

**线程：**

1. 一个进程可以产生多个线程。同多个进程可以共享操作系统里的某些资源一样，同一进程的多个线程也可以共享此进程的某些资源（code，data），所以线程又被称为轻量级进程（lightweight process）。
2. 一个进程内部的一个执行单元，他是程序中的一个单一的顺序控制流程。
3. 一个进程可以拥有多个并行的（concurrent）线程。
4. 一个进程中的多个线程共享相同的内存单元/内存地址空间，可以访问相同的变量和对象，而且他们从同一堆中分配对象那个并进行通信、数据交换和同步操作。
5. 由于线程间的通信是在同一地址空间上进行的，多以不需要额外的通信机制，这就使得通信更简便而且信息传递的速度也更快。
6. 线程的启动、中断、消亡，消耗的资源非常少。

![image-20200523092158403](C:\Users\张辉\Desktop\日常记录\笔记\Java学校\image-20200523092158403.png)

**线程和进程的区别：**

1. 每个进程都有独立的代码和数据空间，进程间的切换会有较大的开销。
2. 线程可以看成是轻量级的进程，属于同一进程的线程共享代码和数据空间，每个线程又独立的运行栈和好吃呢徐计数器（PC），线程切换到开销小。
3. 线程和进程的最根本的区别在于：进程是资源分配的单位，线程是调度和执行的单位。
4. 多进程：在操作系统中能同时运行多个任务（程序）。
5. 多线程：在同一应用程序中有多个顺序流同时执行。
6. 线程是进程的一部分，所以线程有的时候被称为轻量级进程。
7. 一个没有线程的进程是可以被看作单线程的，如果一个进程内拥有多个线程，进程的执行过程不是一条线（线程）的，而是多条线（线程）共同完成的。
8. 系统在运行的时候会为每个进程分配不同的内存区域，但是不会为了线程分配内存（线程所使用的资源是它所属的进程的资源），线程组只能共享资源。那就是说，除了CPU之外（线程在运行的时候要占用CPU资源），计算机内部的软硬件资源的配置与线程无关，线程只能共享它所属进程的资源。

**进程与程序的区别：**

程序是一组指令的集合，它是静态的实体，没有执行的含义。而进程是一个动态的实体，有自己的生命周期。以吧来说，一个进程肯定与一个程序相对应，并且只有一个，但是一个程序可以有多个进程，或者一个进程都没有。除此之外，进程还有并发性和交往性。简单来说：进程是程序的一部分，程序运行的时候会产生进程。

### 通过继承Thread类实现多线程

1. 在Java中负责实现线程功能的类是java.lang.Thread类。
2. 可以通过创建Thread的实例来创建新的线程。
3. 每个吸纳成都是通过某个特定的Thread对象所对应的方法`run()`来完成其操作，方法run()称为线程体。
4. 通过调用Thread类的==start()==方法来启动一个线程。

```java
public class TestThread extends Thread { // 自定义类继承Thread类
    // run()方法里是线程体
    @Override
    public void run() {
        for (int i = 0; i < 10; i++) {
            System.out.println(this.getName() + ":" + i); // getName()方法返回线程名称
        }
    }
    
    public static void main(String[] args) {
        TestThread thread1 = new TestThread(); // 创建线程对象
        thread1.start(); // 启动线程
        TestThread thread2 = new TestThread();
        thread2.start();
    }
}
```

### 通过Runnable接口实现多线程

1. 在应用开发中，我们应用更多的是通过 `Runnable` 接口实现多线程。这种方式克服了 ==Thread== 实现线程类的缺点，即实现 `Runnable `接口的同时还可以继承某个类。

2. 所以实现 `Runnable` 接口的方式要通用一些。

```java
public class TestThread2 implements Runnable { // 自定义类实现Runable接口
    @Override
    public void run() {
        for (int i = 0; i < 10; i++) {
            System.out.println(Thread.currentThread().getName() + ":" + i);
        }
    }
    public static void main(String[] args) {
        // 创建线程对象，把实现了Runnable接口的对象作为参数传入；
        Thread thread1 = new Thread(new TestThread2());
        thread1.start(); // 启动线程
		Thread thread2 = new Thread(new TestThread2());
        thread2.start(); // 启动线程
    }
}
```

### 通过Callable实现多线程

```java
public class CDownloader implements Callable<Boolean> {
    private String url;
    private String name;

    public CDownloader(String url, String name) {
        this.url = url;
        this.name = name;
    }

    @Override
    public Boolean call() throws Exception{
        WebDownloader wd = new WebDownloader(); // WebDownloader为一个web下载的类
        wd.download(url, name);
        System.out.println(name);
        return true;
    }

    public static void main(String[] args) throws ExecutionException, InterruptedException {
        CDownloader cd1 = new CDownloader("https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1588907409428&di=b08ec32df49d24e0153d046b5e37e86e&imgtype=0&src=http%3A%2F%2Fqimg.hxnews.com%2F2018%2F0611%2F1528676232318.jpg","火箭熊.jpg");
        CDownloader cd2 = new CDownloader("https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1588907409428&di=315902600665b2854ac20e3a60a8ec2a&imgtype=0&src=http%3A%2F%2Fimg.zcool.cn%2Fcommunity%2F0105d15724c5886ac725381222c109.jpg%402o.jpg","蜘蛛侠.jpg");
        CDownloader cd3 = new CDownloader("https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1588907837238&di=5519b9b715f0276bb29fc1e07497db54&imgtype=0&src=http%3A%2F%2Fimg.zcool.cn%2Fcommunity%2F01850455450dc50000019ae92d459c.jpg%401280w_1l_2o_100sh.jpg","蜘蛛侠02.jpg");

        // 创建执行服务
        ExecutorService service = Executors.newFixedThreadPool(3);
        // 提交执行
        Future<Boolean> reslut1 = service.submit(cd1);
        Future<Boolean> reslut2 = service.submit(cd2);
        Future<Boolean> reslut3 = service.submit(cd3);
        // 获取结果
        boolean r1 = reslut1.get();
        boolean r2 = reslut2.get();
        boolean r3 = reslut3.get();
        System.out.println(r3);
        // 关闭服务
        service.shutdownNow();

    }
}

```



### 线程状态

![image-20200524230332465](C:\Users\张辉\Desktop\日常记录\笔记\Java学校\image-20200524230332465.png)

#### 新生状态(New)

1. 用new关键字建立一个线程对象后，该线程对象就处于新生状态。
2. 处于新生状态的线程有自己的内存空间，通过调用start方法进入就绪状态。

#### 就绪状态(Runnable)

> 处于就绪状态的线程已经具备了运行条件，但是还没有被分配到CPU，处于“线程就绪队列”，等待系统为其分配CPU。就绪状态并不是执行状态，当系统选定一个等待执行的Thread对象后，她就会进入执行状态。一旦获得CPU，线程就进入运行状态并自动调用自己的run()方法。

线程进入就绪状态的4个原因：

1. **新建线程：** 调用start()方法，进入就绪状态。
2. **阻塞线程：** 阻塞解除，进入就绪状态。
3. **运行进程：** 调用yield()，直接进入就绪状态。
4. **运行状态：** JVM 将 CPU 资源从本线程切换到其他线程。

#### 运行状态(Running)

> 在运行状态的线程执行自己run()方法中的代码，直到调用其他方法而终止或等待某资源而阻塞或完成任务而死亡。

> 如果再给定的时间片内没有执行结束，就会被系统给换下来回到就绪状态。也可能由于某些“导致阻塞的事件”而进入阻塞状态。

#### 阻塞状态(Blocked)

> 阻塞指的是暂停一个线程的执行以等待某个条件发生（如某资源就绪）。有4中原因会导致阻塞。

1. 执行sleep(int millsecond) 方法，使当前线程休眠，进入阻塞状态。当指定的时间到了后，线程进入就绪状态。
2. 执行wait()方法，使当前线程进入阻塞状态。当使用nofity()方法唤醒这个线程后，他进入就绪状态。
3. 线程运行时，某个操作进入阻塞状态，比如执行IO流操作（read()/write()方法本身就是阻塞方法的方法）。只有当引起该操作阻塞的原因消失后，线程进入就绪状态。
4. join() 线程联合：当某个线程等待另一个线程执行结束后，才能继续执行，使用join()方法。

#### 死亡状态(Terminated)

1. 死亡状态是线程声明周期中最后一个阶段。线程死亡的原因有两个。一个是正常运行的线程完成了它run()方法内的全部工作；另一个是线程被强制终止，如通过执行stop()或destroy()方法来终止一个线程（注：stop()/destroy()方法已经被JDK废弃，不推荐使用）。
2. 当一个线程进入死亡状态以后，就不能再回到其他状态了。

### 线程终止的典型方式

> 终止线程我们一般不使用JDK提供的stop()/destory()方法（它们本身也被JDK废弃了）。通常我们的做法是提供一个boolean型的终止变量，当这个变量置为false，则终止线程的运行。

```java
public class TestThreadCiycle implements Runable {
    String name;
    boolean live = true; // 标记变量。表示线程是否可终止。
    
    public TestThreadCiycle(String name) {
        super();
        this.name = name;
    }
    
    @Override
    public void run() {
		int i = 0;
        // 当live的值为true时，继续线程体，false则结束循环，继而终止线程体。
        while(live) {
            System.out.println(name + (i++));
        }
    }
    
    public void terminate() {
        live = false;
    }
    
    public static void main(String[] args) {
        TestThreadCiycle ttc = new TestThreadCiycle("线程A：");
        Thread t1 = new Thread(ttc);// 新生状态
        t1.start(); //就绪状态
        for(int i = 0; i < 100) {
        	System.out.println("主线程：" + i);
        }
        ttc.terminate();
        System.out.println("ttc stop!");
    }
}
```

### 暂停线程执行

> 暂停线程常用的方法有sleep()和yield()方法，这俩方法区别如下：

1. `sleep()`方法：可以让正在运行的线程==进入阻塞状态==，直到休眠时间满了，进入就绪状态。
2. `yield()`方法：可以让正在运行的线程直接==进入就绪状态==，让出CPU的使用权。

3. 使用`yield()`可以引起线程的切换，但运行时没有明显延迟。

```java
// sleep()
public class TestThreadState {
    public static void main(String[] args) {
        StateThread thread1 = new StateThread();
        thread1.start();
        StateThread thread2 = new StateThread();
        thraed2.start();
    }
}
// 使用继承的方式实现多线程
class StateThread extends Thread {
    @Override
    public void run() {
        for (int i = 0; i < 100; i++) {
			System.out.println(this.getName + ":" + i);
            try {
                Thread.sleep(2000); // 调用线程的sleep()方法
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }
}
```

```java
// yield()
public class TestThreadState {
    public static void main(String[] args) {
        Thread thread1 = new Thread(new StateThread);
        Thread thread2 = new Thread(new StateThread);
    	thread1.start();
        thread2.start();
    }
}
// 通过接口Runnable实现多线程
class StateThread implements Runnable {
    @Override
    public void run() {
        for (int i = 0; i < 100; i++) {
            System.out.println(Thread.currentThread.getName() + ":" + i);
            Thread.yield(); // 调用线程的yield()方法。
        }
    }
}
```

### 守护线程(Daemon)

> 守护线程顾名思义，就是保佑其他线程正常运行，不必管自己本身。专业一点：守护线程：是为用户线程服务的；JVM停止不用等待守护线程执行完毕。（没有守护线程的话，用户线程JVM需要等待所有的线程执行完毕，才会停止）

```java
public class DaemonTest {
    public static void main(String[] args) {
        God god = new God();
        You you = new You();

        // 代理
        Thread t = new Thread(god);
        t.setDaemon(true);
        // 将用户线程调整为守护线程，守护线程就是通过这儿设置的。这儿也就是将god线程设置为了守护线程。
        t.start();
        new Thread(you).start();

    }
}

class You implements Runnable{
    @Override
    public void run() {
        for (int i = 0; i < 365*100; i++) {
            System.out.println("happy life...");
        }
        System.out.println("oooooooooooo...");
    }
}

class God implements Runnable{
    @Override
    public void run() {
        for (int i = 0; i < 365*1000000; i++) {
            System.out.println("bless you...");
        }
        System.out.println("oooooooooooo...");
    }
}
```



### 线程的联合join()

> 线程A再运行期间，可以调用线程B的join()方法，让线程B和线程A联合。这样，线程A就必须等待线程B执行完毕后，才能继续执行。如下例：“爸爸线程”要抽烟，于是联合“儿子线程”去买烟，必须等待“儿子线程”买烟完毕，“爸爸线程”才能继续抽烟。

```java
public class TestThreadState {
    public static void mian(String[] args) {
        System.out.println("爸爸和儿子买烟的故事！");
        Thread father = new Thread(new FatherThread());
        father.start();
    }
}
class FatherThread implements Runable {
    @Override
    public void run() {
        System.out.println("爸爸想抽烟，发现烟抽完了!?");
        System.out.println("爸爸让儿子去买包烟");
        Thread son = new Thread(new SonThread());
        son.start();
        System.out.println("爸爸等儿子买烟回来");
        try {
            son.join();
        } catch (INterruptedException e) {
            e.printStackTrace();
            System.out.println("爸爸出门找儿子跑哪去了");
            System.exit(1);
        }
        System.out.println("爸爸高兴的接过烟开始抽，并把零钱给了儿子");
    }
}
class SonThread implements {
    @Override
    public void run() {
        System.out.println("儿子出门买烟");
        System.out.println("买烟需要10分钟");
        try {
            for (int i = 1; i <= 10; i++) {
                System.out.println("第" + i + "分钟");
                Thread.sleep(1000);
            }
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        System.out.println("儿子买烟回来了");
    }
}
```

**运行结果为：**

![image-20200525092823123](C:\Users\张辉\Desktop\日常记录\笔记\Java学校\image-20200525092823123.png)

### 获取线程基本信息的方法

|      方法       | 功能                                           |
| :-------------: | :--------------------------------------------- |
|    isAlive()    | 判断线程是否还活着，即线程是否还未终止         |
|  getPriority()  | 获得线程的优先级数值                           |
|  setPriority()  | 设置线程的优先级数值                           |
|    setName()    | 给线程一个名字                                 |
|    getName()    | 获得线程的名字                                 |
| currentThread() | 获得房前正在运行的线程对象，也就是取得自己本身 |

```java
public class TestThread {
    public static void main(String[] args) throws Exception {
        Runnable r = new MyThread();
        Thread t = new Thread(r, "Name test"); // 定义线程对象，并传入参数;
        t.start(); // 启动线程
        System.out.println("Name is:" + t.getName()); // 输出线程名称
        Thread.currentThread().sleep(5000); // 线程暂停5s。
        System.out.println(t.isAlive()); // 判断线程还在运行吗？
        System.out.println("over!");
    }
}
class MyThread implements Runnable {
    @Override
    public void run() {
        for (int i = 0; i < 10; i++) {
            System.out.println(i);
        }
    }
}
```

### 线程的优先级

> 优先级低只是意味着获得调度的概率低。并不是绝对先调用优先级高的线程后调用优先级低的线程。

1. 处于就绪状态的线程，会进入“就绪队列”等待JVM来挑选。

2. 线程的优先级用数字表示，范围从1到10，一个线程缺省优先级是5.

3. 使用下列方法获得或设置线程对象的优先级。

   ```java
   int getPriority();
   void setPriority(int newPriority);
   ```

```java
public class TestThread {
    public static void mian(String[] args) {
        Thread t1 = new Thread(new MyThread(), "t1");
        Thread t2 = new Thread(new MyThread(), "t2");
        t1.setPriority(1);
        t2.setPriority(10);
        t1.start();
        t2.start();
    }
}
class MyThread extends Thread {
    public void run() {
        for (int i = 0; i < 10; i++) {
            System.out.println(Thread.currentThread().getName() + ": " + i);
        }
    }
}
```

### 线程同步

> 处理多线程问题时，多个线程访问一个对象，并且某些线程还想修改这个对象。这时候，我们就需要用到“线程同步”。线程同步起始就是一种等待机制，多个需要同时访问此对象的线程进入这个对象的等待池形成队列，等待前面的线程使用完毕后，下一个线程再使用。

#### 多线程操作同一个对象（未使用线程同步）

```java
public class TestSync {
    public static void main(String[] args) {
        Account a1 = new Account(100, "高");
        Drawing draw1 = new Drawing(80, a1);// 定义取钱线程对象；
        Drawing draw2 = new Drawing(80, a1);// 定义取钱线程对象；
        draw1.start(); // 你取钱
        draw2.start(); // 你老婆取钱
    }
}
/*
 * 简单表示银行账户
 */
class Account {
    int money;
    String aname;
 
    public Account(int money, String aname) {
        super();
        this.money = money;
        this.aname = aname;
    }
}
/**
 * 模拟提款操作
 */
class Drawing extends Thread {
    int drawingNum; // 取多少钱
    Account account; // 要取钱的账户
    int expenseTotal; // 总共取的钱数
 
    public Drawing(int drawingNum, Account account) {
        super();
        this.drawingNum = drawingNum;
        this.account = account;
    }
 
    @Override
    public void run() {
        if (account.money - drawingNum < 0) {
            return;
        }
        try {
            Thread.sleep(1000); // 判断完后阻塞。其他线程开始运行。
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        account.money -= drawingNum;
        expenseTotal += drawingNum;
        System.out.println(this.getName() + "--账户余额：" + account.money);
        System.out.println(this.getName() + "--总共取了：" + expenseTotal);
    }
}
```

**未使用线程同步的结果**

![image-20200525110716677](C:\Users\张辉\Desktop\日常记录\笔记\Java学校\image-20200525110716677.png)

#### 实现线程同步

1. 由于同一线程的多个线程共享同一块存储空间，在带来方便的同时，也带来了访问冲突的问题。Java语言提供了专门机制解决这种冲突，有效避免了同一个数据对象被多个线程同时访问造成的这种问题。
2. 由于我们可以通过==private== 关键字来保证数据对象只能被访问，所以我们只需针对方法提出一套机制，这套机制就是`synchronized` 关键字，它包括两种用法：`synchronized方法`和`synchronized块`。

##### synchronized方法

1. 通过在方法声明中加入==synchronized== 关键字来声明，如： `public synchronized void accessVal(int newVal);`
2. synchronized方法控制对“对象的类成员变量”的访问：==每个对象对应一把锁==，每个synchronized方法都必须获得调用该方法的对象的锁方能执行，否则所属线程阻塞，方法一旦执行，就独占改锁，直到该方法返回时才将锁释放，此后被阻塞的线程方能获得该锁，重新进入可执行的状态。

##### synchronized块

1. synchronized方法的缺陷：若将一个大的方法声明为synchronized将会大大影响效率。
2. Java为我们提供了更好的解决办法，那就是synchronized块。块可以让我们精确地控制到具体的“成员变量”，缩小同步的范围，提高效率。
3. synchronized块语法为：`synchronized(syncObject){允许空值的代码}`

```java
public class TestSync {
    public static void main(String[] args) {
        Account a1 = new Account(100, "高");
        Drawing draw1 = new Drawing(80, a1);
        Drawing draw2 = new Drawing(80, a1);
        draw1.start(); // 你取钱
        draw2.start(); // 你老婆取钱
    }
}
/*
 * 简单表示银行账户
 */
class Account {
    int money;
    String aname;
    public Account(int money, String aname) {
        super();
        this.money = money;
        this.aname = aname;
    }
}
/**
 * 模拟提款操作
 * 
 * @author Administrator
 *
 */
class Drawing extends Thread {
    int drawingNum; // 取多少钱
    Account account; // 要取钱的账户
    int expenseTotal; // 总共取的钱数
 
    public Drawing(int drawingNum, Account account) {
        super();
        this.drawingNum = drawingNum;
        this.account = account;
    }
 
    @Override
    public void run() {
        draw();
    }
 
    void draw() {
        synchronized (account) {
            // 这儿锁定的时account账户
            if (account.money - drawingNum < 0) {
                System.out.println(this.getName() + "取款，余额不足！");
                return;
            }
            try {
                Thread.sleep(1000); // 判断完后阻塞。其他线程开始运行。
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            account.money -= drawingNum;
            expenseTotal += drawingNum;
        }
        System.out.println(this.getName() + "--账户余额：" + account.money);
        System.out.println(this.getName() + "--总共取了：" + expenseTotal);
    }
}
```

4. “synchronized(account)” 意味着线程需要获得account对象的“锁”才有资格运行同步块中的代码。Account对象的“锁”也称为“互斥锁”，在同一时刻只能被一个线程使用。
5.  A线程拥有锁，则可以调用“同步块”中的代码;B线程没有锁，则进入account对象的“锁池队列”等待，直到A线程使用完毕释放了account对象的锁，B线程得到锁才可以开始调用“同步块”中的代码。 

### 死锁及解决方案

#### 死锁

1. 死锁是指，各个线程各自占有一些共享资源，并且互相等待其他线程占有的资源才能进程，而导致两个或多个线程都在等待对方释放资源，都停止执行的情形。
2. 比如三个人吃饭，没两个人中间放着一种餐具，要每个人手里都拿到两个餐具才能吃饭，但是同时开始吃饭的话，就会造成，每人拿着一个餐具，都不能吃饭的结局。

```java
class Lipstick {
    // 口红类
}
class Mirror {
    // 镜子类
}
class Makeup extends Thread {
    // 化妆类继承了Thread类
    int flag;
    String girl;
    static Lipstick lipstick = new Lipstick();
    static Mirror mirror = new Mirror();
    
    @Override
    public void run() {
		doMakeup();
    }
    void doMakeup() {
		if (flag == 0) {
            synchronized (lipstick) {
                // 需要拿到口红的锁
                System.out.println(girl + "拿着口红！");
                try {
                    Thread.sleep(1000);
                } catch (InterruptedException e){
                    e.printStackTrace();
                }
                
                synchronized (mirror) {
                    // 需要得到镜子的锁
                    System.out.println(girl + "拿着镜子！");
                }
            }
        } else {
            synchronized (mirror) {
                // 需要拿到口红的锁
                System.out.println(girl + "拿着镜子！");
                try {
                    Thread.sleep(2000);
                } catch (InterruptedException e){
                    e.printStackTrace();
                }
                
                synchronized (lipstick) {
                    // 需要得到镜子的锁
                    System.out.println(girl + "拿着口红！");
                }
            }
        }
    }
}
public class TestDeadLock {
    public static void main(String[] args) {
        Makeup m1 = new Makeup();//大丫的化妆线程；
        m1.girl = "大丫";
        m1.flag = 0;
        Makeup m2 = new Makeup();//小丫的化妆线程；
        m2.girl = "小丫";
        m2.flag = 1;
        m1.start();
        m2.start();
    }
}
// 这样互相持锁，造成死锁
```

#### 死锁的解决方法

> 死锁是由于“同步块需要同时持有两个对象锁造成”的，要解决这个问题，思路很简单，就是同一个代码块，不要同时持有两个对象的锁。

```java
class Lipstick {//口红类
 
}
class Mirror {//镜子类
 
}
class Makeup extends Thread {//化妆类继承了Thread类
    int flag;
    String girl;
    static Lipstick lipstick = new Lipstick();
    static Mirror mirror = new Mirror();
 
    @Override
    public void run() {
        // TODO Auto-generated method stub
        doMakeup();
    }
 
    void doMakeup() {
        if (flag == 0) {
            synchronized (lipstick) {
                System.out.println(girl + "拿着口红！");
                try {
                    Thread.sleep(1000);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
 
            }
            synchronized (mirror) {
                System.out.println(girl + "拿着镜子！");
            }
        } else {
            synchronized (mirror) {
                System.out.println(girl + "拿着镜子！");
                try {
                    Thread.sleep(2000);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            synchronized (lipstick) {
                System.out.println(girl + "拿着口红！");
            }
        }
    }
}
 
public class TestDeadLock {
    public static void main(String[] args) {
        Makeup m1 = new Makeup();// 大丫的化妆线程；
        m1.girl = "大丫";
        m1.flag = 0;
        Makeup m2 = new Makeup();// 小丫的化妆线程；
        m2.girl = "小丫";
        m2.flag = 1;
        m1.start();
        m2.start();
    }
}
// 这儿没有锁的重复，也就是锁里边没有锁，所以不会造成互相持锁，造成死锁的这种情况。
```

### 线程并发协作

> 在多线程环境下，我们经常需要多个线程变并发和协作。这个时候，我们就需要了解一个重要的多线程并发协作模式“生产者/协作者模式”。

**什么是生产者？**

> 生产者指的是负责生产数据的模块（这里的模块可能是：对象，方法，线程，进程）。

**什么是消费者？**

> 消费者的是负责处理无数据的模块（这里的模块可能是：方法，对象，进程，线程）。

**什么是缓冲区？**

> 消费者不能直接使用生产者的数据，他们之间有个“缓冲区”。生产者将生产好的数据放入“缓冲区”，消费者从“缓冲区”拿要处理的数据。

![image-20200526093958793](C:\Users\张辉\Desktop\日常记录\笔记\Java学校\image-20200526093958793.png)

**实现线程的并发协作**

1. 有了缓冲区以后，生产者线程只需要往缓冲区里面防止数据，而不需要管消费者的情况；同样，消费者只需要从缓冲区拿数据处理即可，也不用管生产者生产的情况。这样，就从逻辑上实现了“生产者线程”和“消费者线程”的分离。
2. 解耦了生产者和消费者：生产者不需要和消费者直接打交道。
3. 解决了忙闲不均，提高效率：生产者生产数据慢时，缓冲区仍有数据，不影响消费者消费；消费者处理数据慢时，生产者仍然可以继续往缓冲区里边放置数据。
4. 这样就会并发协作，你放一个，我拿一个，没了我就等待；放满了，你就等会儿放。

#### 管程法

```java
public class TestProduce {
    public static void main(String[] args) {
        SyncStack sStack = new SyncStack(); // 定义缓冲区对象；
        Shengchan sc = new Shengchan(sStack); // 定义生产线程；
        Xiaofei xf = new Xiaofei(sStack); // 定义消费线程；
        sc.start();
        xf.start();
    }
}

class Mantou {// 馒头
    int id;
    
    Mantou(int id) {
        this.id = id;
    }
}

class SyncStack {// 缓冲区（相当于：馒头框）
    int index = 0;
    Mantou[] ms = new Mantou[10];
    
    public synchronized void push(Mantou m) {
        while(index == ms.length) {// 说明馒头筐满了
        	try {
                this.wait();
                /*
                	wait后，线程会将持有的锁释放，进入阻塞状态；
                	这样其他需要锁的线程就可以获得锁；
                	这里的含义是执行此方法的线程暂停，进入阻塞状态，等消费者消费了馒头后再生产。
                */
            } catch (InterruptedException e) {
				e.printStackTrace();
            }
        }
        this.notify();
        /*
        	唤醒再当前对象等待池的第一个线程。
        	notifyAll叫醒所有在线程等待池种等待的所有线程。
        	如果不唤醒的话，以后这两个线程都会进入等待线程，没有人唤醒。
        */
        ms[index] = m;
        index++;
    }
    
    public synchronized Mantou pop() {
        while(index == 0) {// 如果馒头是空的
            try {
                this.wait();
                /*
                	如果馒头筐是空的，就暂停此消费线程（因为没有东西再可以消费了），等生产线程生产完再来消费。
                */
            } catch (InterruptedExceptio e) {
                e.printStackTrace();
            }
        }
        this.notify();
        index--;
        return ms[index];
    }
}

class Shengchan extends Thread {// 生产者线程
	SyncStack ss = null;
    
    public Shengchan(SyncStack ss) {
        this.ss = ss;
    }
    
    @Override
    public void run() {
        for (int i = 0; i < 10; i++) {
            System.out.println("生产馒头：" + i);
            Mantou m = new Mantou(i);
            ss.push(m);
        }
    }
}

class Xiaofei extends Thread {// 消费者线程
	SyncStack ss = null;
    
    public Xiaofei(SyncStack ss) {
        this.ss = ss;
    }
    
    @Override
    public void run() {
        for (int i = 0; i < 10; i++) {
            Mantou m = ss.pop();
            System.out.println("消费馒头：" + i);
        }
    }
}
```

#### 信号灯法

```java
public class CoTest02 {
    public static void main(String[] args) {
        Tv tv = new Tv();
        new Player(tv).start();
        new Watcher(tv).start();
    }
}
// 生产者 演员
class Player extends Thread{
    Tv tv;

    public Player(Tv tv) {
        this.tv = tv;
    }

    @Override
    public void run() {
        for (int i = 0; i < 20; i++) {
            if (i %2 ==0) {
                this.tv.play("奇葩说");
            }else {
                this.tv.play("太污了！");
            }
        }
    }
}
// 消费者 观众
class Watcher extends Thread{
    Tv tv;

    public Watcher(Tv tv) {
        this.tv = tv;
    }

    @Override
    public void run() {
        for (int i = 0; i < 20; i++) {
            tv.watch();
        }
    }
}
// 同一个资源 电视
class Tv{
    String voice;
    // 信号灯
    // T表示演员表演，观众等待
    // F表示观众观看，演员等待
    boolean flag = true;

    // 表演
    public synchronized void play(String voice){
        // 演员等待
        if (!flag) {
            try {
                this.wait();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }

        System.out.println("表演了：" + voice);
        this.voice = voice;
        this.notifyAll();
        this.flag = !this.flag;
    }

    // 观看
    public synchronized void watch(){
        // 观众等待
        if (flag) {
            try {
                this.wait();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
        System.out.println("听到了：" + voice);
        this.notifyAll();
        this.flag = !this.flag;
    }
}
```



#### 线程并发协作总结

> 线程并发协作（也叫线程通信），通常用于生产者/消费者模式。

1. 生产者和消费者共享一个资源，并且没有生产者和消费者之间的相互依赖（你干你的，我干我的），互为条件。
2. 对于生产者，没有生产产品之前，消费者要进入等待状态。而生产了产品之后，又需要马上通知消费者消费。
3. 对于消费者，在消费了后，要通知生产者已经消费结束，需要继续生产新产品以共消费。
4. 在生产者消费者问题中，仅有==synchronized== 是不够的。
   + synchronized 可阻止并发更新同一个共享资源，实现了同步；
   + synchronized 不能用来实现不同线程之间的消息传递（通信）。
5. 线程之间通过以下方法来进行消息传递（这些方法都是==java.lang.Object==类的方法，这些方法都只能在`同步方法或者同步代码块`中使用，否则抛出异常）：

| 方法名                                  | 作用                                                         |
| --------------------------------------- | ------------------------------------------------------------ |
| final void wait()                       | 表示线程一直等待，直到得到其他线程通知                       |
| void wait(long timeout)                 | 线程等待指示毫秒参数的时间                                   |
| final void wait(long timeout,int nanos) | 线程等待指示毫秒、微妙的时间                                 |
| final void notify()                     | 唤醒一个处于等待状态的线程                                   |
| final void notifyAll()                  | 唤醒同一个对象上所有调用的wait()方法的线程，优先级别搞得线程优先运行。 |

### 任务定时调度

> 通过Timer和TimerTask，我们可以实现定时启动某个线程

**java.util.Timer**

> 这种实现方式中，Timer类作用是类似闹钟的功能，也就是定时或者每隔一定的时间触发一次线程。其实。Timer来本身就是一个线程，只是这个线程使用来实现其他线程的。

**java.util.TimerTask**

> TimerTask类是一个抽象类，该类实现了Runnable接口。
>
> 所以该类具备多线程的能力。在这种实现方式中，通过继承TimerTask使该类获得多线程的能力，将需要多线程执行的代码书写在run()方法内部，通过Timer类启动线程执行。

```java
public class TestTimer {
    public static void main(String[] args) {
        Timer t1 = new Timer(); // 定义计时器
        MyTask task1 = new MyTask(); // 定义任务；
        //t1.schedule(task1,3000); // 3s后执行；
        //t1.schedule(task1,5000,1000); // 5s以后每个1s执行一次！
        GregorianCalendar calendar1 = new GregorianCalendar(2099,1,1,1,20,30);
        t1.schedule(task1,calendar1.getTime()); // 指定时间定时执行。
    }
}

class MyTask extends TimerTask {//自定义线程类继承TimerTask类；
	@Override
    public void run() {
        for(int i = 0; i < 10; i++) {
            System.out.println("任务1：" + i);
        }
    }
}
```

 在实际使用时，一个Timer可以启动任意多个TimerTask实现的线程，但是多个线程之间会存在阻塞。所以如果多个线程之间需要完全独立的话，最好还是一个Timer启动一个TimerTask实现。 

### Lambda

1. Lambda表达式也可称为闭包，它是推动java8发布的最重要的新特性。
2. Lambda允许把函数作为一个方法的参数（函数作为参数传递进方法）。

**语法**

```java
(parameters) -> expression
或
(parameters) -> {statements;}
```

3. Lambda重要特征
   + **可选类型声明：**不需要声明参数类型，编译器可以统一识别参数值。
   + **可选的参数圆括号：**一个参数无需定义圆括号，但多个参数需要定义圆括号。
   + **可选的大括号：**如果主体包含了一个语句，就不需要使用大括号。
   + **可选的返回关键字：**如果主体只有一个表达式返回值则编译器会自动返回值，大括号需要指定表达式返回了一个数值。

```java
// 1. 不需要参数，返回值为5
() -> 5
    
// 2. 接收一个参数（数字类型），返回其2倍的值
x -> 2 * x
    
// 3. 接受2个参数（数字），并返回他们的差值
(x, y) -> x - y

// 4. 接收2个int型整数，返回他们的和
(int x, int y) -> x + y
    
// 5. 接收一个String对象，并在控制台打印，不返回任何值（看起来像是void）
(String s) -> System.out.println(s)
```

```java
public class Java8Tester {
    public static void main(String[] args) {
        Java8Tester tester = new Java8Tester();
        
        // 类型声明
        MathOperation addition = (int a, int b) -> a + b;
        
        // 不用类型声明
        MathOperation subtraction = (a, b) -> a - b;
        
        // 大括号中返回语句
        MathOperation multiplication = (int a, int b) -> {return a * b};
        
        // 没有大括号及返回语句
        MathOperation division = (int a, int b) -> a / b;
        
        System.out.println("10 + 5 = " + tester.operate(10, 5, addition));
		System.out.println("10 - 5 = " + tester.operate(10, 5, subtraction));
		System.out.println("10 x 5 = " + tester.operate(10, 5, multiplication));
		System.out.println("10 / 5 = " + tester.operate(10, 5, division));
        
      	// 不用括号
		GreetingService greetService1 = message ->System.out.println("Hello " + message);
        
      // 用括号
		GreetingService greetService2 = (message) ->System.out.println("Hello " + message);
        
      greetService1.sayMessage("Runoob");
      greetService2.sayMessage("Google");
    }
    private int operate(int a, int b, MathOperation mathOperation) {
        return mathOtheration.opteration(a, b);
    }
}
interface MathOperation {
    int operation(int a, int b);
}
interface GreetingService {
    void sayMessage(String message);
}
```

4. Lambda表达式注意：
   + Lambda表达式主要用来定义行内执行的方法类型接口，例如：一个简单方法接口。
   + Lambda表达式免去了使用匿名方法的麻烦，并且给予Java简单但是强大的函数化的编程能力。
5. Lambda变量作用域
   + Lambda表达式只能引用标记了final的外层局部变量，这就是说不能在lambda内部修改定义在域外的局部变量，否则会编译报错。
   +  可以直接在 lambda 表达式中访问外层的局部变量
   +  lambda 表达式的局部变量可以不用声明为 final，但是必须不可被后面的代码修改（即隐性的具有 final 的语义） 
   +  在 Lambda 表达式当中不允许声明一个与局部变量同名的参数或者局部变量。 

### 静态代理（Proxy）

> 代理模式，简单来说，就是一个人专门负责干想干的事儿，其他事情不用你处理，会有人帮你处理

比如：你要结婚，你只需要happy，婚庆公司会帮你做好其他事物的。这就是代理模式。静态代理就是这一套流程是固定的，不会发生变化的，所以是静态代理。

```java
public class StaticProxy {
    public static void main(String[] args) {
        new WeddingCompany(new You()).happyMarry();
        //new Thread(线程对象).start();
    }
}

interface Marry{
    /**
     * 结婚的接口
     */
    void happyMarry();
}

class You implements Marry{
    @Override
    public void happyMarry() {
        System.out.println("you and you girlfriend 。。。");
    }
}

/**
 * 代理角色
 */
class WeddingCompany implements Marry{
    /**
     * 真实角色
     */
    private Marry target;

    public WeddingCompany(Marry target) {
        this.target = target;
    }

    @Override
    public void happyMarry() {
        this.ready();
        this.target.happyMarry();
        this.after();
    }

    private void ready(){
        System.out.println("布置主卧！");
    }

    private void after(){
        System.out.println("闹洞房！");
    }
}
```

# Java进阶

## 网络编程

### 基本概念

#### 什么是计算机网络

1. 计算机网络是指将地理位置不同的具有独立功能的多台计算机及其外部设备，通过通信线路链接起来，在网络操作系统中，网络管理软件及网络通信协议的管理和协调下，实现资源共享和信息传递的计算机系统。

2. 计算机网络的作用：资源共享和信息传递。
3. 计算机网络的组成：
   1. 计算机硬件：计算机（大中小型服务器，台式机，笔记本等）、外部设备（路由器、交换机等）、通信线路（双绞线、光纤等）。
   2. 计算机软件：网络操作系统（Windows 200 Server/Advance Server、Unix、Linux等），网络管理系统（WorkWin、SugaNMS等）、网络通信协议（如：TCP/IP协议栈等）。
4. 计算机网络的多台计算机是具有独立功能的，而不是脱离了网络就无法存在的。

#### 什么是网络通信协议

1. 通过计算机网络可以实现不同计算机之间的连接与通信，但是计算机网络中实现通信必须有一些`约定`==通信协议，对速率、传输代码、代码结构、传输控制步骤、出错控制==等制定标准。就像两个人想要顺利沟通就必须使用同一种语言一样，如果一个人只懂英语而另外一个人只懂中文，这样就会造成没有共同语言而无法沟通。
2. 国际标准化（ISO，即International Organization for Standardization）定义了通信网络协议的基本框架，被称为OSI（Open System Interconnect，即开发系统互联）模型。OSI模型制定的七层标准模型，分别是：应用层，表示层，会话层，传输层，网络层，数据链路层，物理层。

 ![图12-1 七层协议模型.png](C:\Users\张辉\Desktop\日常记录\笔记\Java学校\1495936432794161.png) 

3. 虽然国际标准化组织制定了这样一个网络通信协议的模型，但是实际上是TCP/IP网络通信协议。

#### TCP/IP协议和OSI模型有什么区别

1. OSI网络网络通信协议模型是一个参考模型，而TCP/IP协议是事实上的标准。TCP/IP协议参考了OSI模型，但是并没有严格按照OSI的七层标准区划分，而只划分了四层，这样会跟简单点，当划分太多层时，你很难区分某个协议时属于哪个层次的。
2. TCP/IP协议和OSI模型也并不冲突，TCP/IP协议中的应用层协议，就对应于OSI中的应用层、表示层、会话层。本质没有多大区别。
3. TCP/IP中有两个重要的协议，传输层的TCP协议和互联网络层的IP协议，因此就拿这两个协议做代表，来命名整个协议族了，再说TCP/IP协议时，是指整个协议族。

#### 网络协议的分层

1. 由于网络节点之间联系很复杂，在制定协议时，把复杂成分分解成一些简单的蹭分，再讲他们复合起来。最常用的复合方式是层次方式，即同层间可以通信、上一层可以调用下一层，而与下一层不发生关系。
2. 把用户应用程序作为最高层，把物理通信线路作为最底层，将其间的协议处理分为若干层，规定每层处理的任务，也规定每层的接口标准。
3. OSI模型与TCP/IP模型的对应关系如下：

 ![img](C:\Users\张辉\Desktop\日常记录\笔记\Java学校\u=210561281,379681344&fm=15&gp=0.jpg) 

#### 数据的封装与分解

1. 由于用户传输的数据一般都比较大，有的可以达到MB字节，一次性发送出去十分困难，于是就需要把数据分成许多片段，再按照一定的次序发送出去。这个过程就需要对数据进行封装。
2. 数据封装（Data Encapsulation）是指将协议数据单元（PDU）封装在一组协议头和协议尾中的过程。在OSI七层参考模型中，每层主要负责与其他机器上的对等层进行通信。该过程是在协议数据单元（PDU）中实现，其中每层的PDU一般由本层的协议头、协议尾和数据封装构成。

##### 数据发送处理过程

1. 应用层将数据交给传输层，传输层添加上TCP的控制信息（称为TCP头部），这个数据单元称为段（Segment），加入控制信息的过程称为封装。然后，将段交给网络层。
2. 网络层接收到段，在添加上IP头部，这个数据单元称为包（Packet）。然后，将包交给数据链路层。
3. 数据链路层接收到包，再添加上MAC头部和尾部，这个数据单元称为帧（Frame）。然后，将帧交给物理层。
4. 物理层将接收到的数据转化成为比特流，然后在网线中传送。

##### 数据接收处理过程

1. 物理层接收到比特流，经过处理后将数据交给数据链路层。
2. 数据链路层将接收到的数据转化为数据帧，再除去MAC头部和尾部，这个除去控制信息的过程称为解封，然后将包交给网络层。
3. 网络层接收到包，再去除IP头部，然后将段交给传输层。
4. 传输层接收到段，再除去TCP头部，然后将数据交给应用层。

##### 数据传输总结

1. 发送方数据处理的方式是从高处到底层，逐层进行封装。
2. 接收方数据处理的方式是从底层到高层，逐层进行数据解封装。
3. 接收方的每一层只把对该层有意义的数据拿走，或者说每一层只能处理发送方同等层的数据，然后把其余的部分传递给上一层，这就是对等层通信的概念。 

 ![img](C:\Users\张辉\Desktop\日常记录\笔记\Java学校\u=1908806067,1573442105&fm=26&gp=0.jpg) 

#### IP标识

1. 用来标识网络中的一个通信实体的地址。通信实体可以是计算机、路由器等。比如互联网的每个服务器都有自己的IP地址，而每个局域网的计算机要通信也要配置IP地址。路由器是连接两个或多个网络的网络设备。
2. 目前主流的IP地址是IPV4，但是随着网络规模的不断扩大，IPV4面临着枯竭的危险，所以推出了IPV6。
3. IPV4：32位地址，并以8位位一个单位，分为四部分，以点分十进制标识，如：192.168.0.1。因为8位二进制的技术范围是00000000---11111111，对应十进制的0-255，所以-4.278.4.1是错误的IPV4地址。
4. IPV6:128位（16个字节）写成8个16位的无符号整数，每个整数用四个十六进制位表示，每个数之间用冒号（:）分开，如： ==3ffe:3201:1401:1280:c8ff:fe4d:db39:1984== 

**注意：**

+ 127.0.0.1本机地址
+  192.168.0.0--192.168.255.255为私有地址，属于非注册地址，专门为组织机构内部使用（家里的路由器段就是这样的）。 

#### 端口

1. IP地址用来标识一台计算机，但是一台计算机上可能提供多种网络应用程序，如何来区分这些不同的程序呢？就要用到端口。
2. 端口是虚拟的概念，并不是说在主机上真的有若干个端口。通过端口，可以再一个主机上运行多个网络应用程序。端口的标识是一个16位的二进制整数，对应十进制的0-65535.
3. IP地址好比每个人的地址（门牌号），端口好比是房间号。必须同时制定IP地址和端口号才能够正确的发送数据。
4. 端口默认为80端口。

#### URL

+ 在www上，每一信息资源都有统一且唯一的地址，该地址就叫URL（Uniform Resource Locator），它是www的统一资源定位符。URL有四部分组成：==协议、存放资源的主机域名、资源文件名和端口号==。如果未制定该端口号，则使用默认的端口。例如http协议的默认端口未80。在浏览器中访问网页时，地址栏显示的地址就是URL。
+ http://www.baidu.com:80/index?uname=shsxt&age=18#a   比如这个URL由 `协议 + 域名/IP + 端口 + 资源 + ? + 请求参数 + # + 锚点 `

#### Socket

1. 我们在开发的网络应用程序位于应用层，==TCP和UDP==属于传输层协议，在应用层如何使用传输层的服务呢？在应用层和传输层之间，则是使用套接Socket来进行分离。
2. 套接字就像是传输层为应用层开的一个小口，应用程序通过这个小口向远程发送数据，或者接收远程发来的数据；而这个小口以内，也就是数据进入这个口之后，或者数据从这个口出来之前，是不知道也不需要知道的，也不会关心它如何传输，这属于网络其他层次工作。
3. Socket实际是传输层提供给应用层的编程接口。Socket就是应用层与传输层时间的桥梁。使用Socket编程可以开发客户机和服务器应用程序，可以在本地网咯上进行通信，也可通过Internet在全球范围内通信。

 ![图12-5 Socket的作用.png](C:\Users\张辉\Desktop\日常记录\笔记\Java学校\1495936842448637.png) 

### TCP协议

> TCP(Tramsfer Control Protocol)是面向连接的，所谓面向连接，就是当计算机双方通信时必须经过先建立连接，然后传送数据，最后关闭连接三个过程（Three-way Handshake）。

1. 第一步，是请求端（客户端）发送一个包含SYN即同步（Synchronized）标志的TCP报文，SYN同步报文会指明客户端使用的端口以及TCP连接的初始序号。
2. 第二步，服务器在收到客户端的SYN报文后，将返回一个SYN+ACK的报文，表示客户端的请求被接收，同时TCP序号被加一，ACK即确认（Acknowledgement）。
3. 第三步，客户端也返回一个报文ACK给服务器端，同样TCP序列号被加一，到此一个TCP连接完成

### UDP协议

> 基于TCP协议可以建立稳定连接的点对点的通信协议。这种通信方式实时、快速、安全性高，但是很占系统的资源。

在网络传输方式上，还有另一种基于UDP协议的通信方式，也称为数据报通信方式。在这种方式中，每个数据发送单元被统一封装成数据包的方式，发送方将数据报包发送到网络中，数据报包在网络中去寻找它的目的地。

### TCP协议和UDP协议的联系和区别

1. TCP协议和UDP协议是传输层的两种协议。Socket是传输层供应给应用层的编程接口，所以Socket编程就分为TCP编程和UDP编程两类。
2. 在网络通讯时，TCP方式就类似于拨打电话，使用该种方式进行网络通讯时，需要建立专门的虚拟连接，然后进行可靠的数据传输，如果数据发送失败，则客户端会自动重发该数据。而UDP方式就类似于发送短信，使用这种方式进行网络通讯时，不需要建立专门的虚拟连接，传输也不是很可靠，如果发送失败则客户端无法获得。
3. 这两种传输方式都在实际的网络编程中使用，重要的数据一般使用TCP方式精心数据传输，而大量的非核心数据则可以通过UDP方式传递，在一些程序中甚至结合使用这两种方式进行数据传递。
4. 由于TCP需要建立专用的虚拟连接以及确认传输是否正确，所以使用TCP方式的速度稍微慢一些，而且传输时产生的数据量要比UDP稍微大一些。

**总结**

+ TCP是面向连接的，传输数据安全，稳定，效率相对较低。
+ UDP是面向无连接的，传输数据不安全，效率较高。

### Java网络编程

> java为了可移植性，不允许直接操作系统，而是由java.net包来提供网络功能。Java虚拟机负责提供与操作的实际连接。

#### InetAddress

1. 作用：封装计算机的IP地址和DNS（没有端口）。（DNS是Domain Name System，域名系统）

2. 特点：这个类没有构造方法。如果得到对象，只能通过静态方法：

   ```java
   getLocalHost();
   //返回本机主机的地址
   getByName(String host);
   //确定主机名称的IP地址。
   getAllByName(String host,byte[] addr);
   //给定主机的名称，根据系统上配置的名称服务返回器IP地址数组
   getByAddress(byte[] addr);
   //给出原始IP地址的InetAddress对象
   getByAddress(String host, byte[] addr);
   //根据提供的主机名和IP地址创建InetAddress。
   
   // 成员方法
   getHostAddress(); 
   //返回文本显示中的IP地址字符串
   getAddress();
   //返回此 InetAddress对象的原始IP地址。
   getHostName();
   //获取此IP地址的主机名。
   ```

```java
import java.net.InetAddress;
import java.net.UnknownHostException;
/**
 * @author 张辉
 * @Description IP 定位一个节点：计算机、路由、通讯设备
 * InetAddress: 多个静态方法
 * 1. getLocalHost(): 获取本机
 * 2. getByName(): 根据域名DNS --》 IP地址
 *
 * 两个成员方法：
 * 1. getHostAddress: 返回地址
 * 2. getHostName: 返回计算机名
 * @create 2020-05-31 9:22
 */
public class IPTest {
    public static void main(String[] args) throws UnknownHostException {
        // 使用getLocalHost方法创建InetAddress本机对象
        InetAddress addr = InetAddress.getLocalHost();
        System.out.println(addr.getHostAddress()); // 返回：192.168.1.149
        System.out.println(addr.getHostName()); // 返回：计算机名

        // 根据域名得到InetAddress对象
        addr = InetAddress.getByName("www.ali.com");
        System.out.println(addr.getHostAddress()); // 返回baidu服务器的ip：36.152.44.95
        System.out.println(addr.getHostName()); // 输出：www.baidu.com

        // 根据ip得到inetAddress对象
        addr = InetAddress.getByName("36.152.44.95");
        System.out.println(addr.getHostAddress()); // 返回ip:36.152.44.95
        System.out.println(addr.getHostName()); //输出ip而不是域名。如果这个IP地址不存在或者DNS服务器不允许进行IP地址和域名的映射，getHostName()方法就直接返回IP地址

    }
}
```

#### InetSocketAddress

> 作用：包含IP和端口信息，常用于Socket通信。此类实现IP套接字地址（IP地址 + 端口号），不依赖任何协议。

```java
import java.net.InetSocketAddress;

/**
 * @author 张辉
 * @Description 端口
 * 1. 区分软件
 * 2. 2个字节 0-65535 UDP TCP
 * 3. 同一个协议端口不能冲突
 * 4. 定义端口越大越好
 * InetSocketAddress (Socket就是有端口的)
 * 1. 构造器
 * new InetSocketAddress(地址|域名,端口);
 * 2. 方法
 * getAddress();
 * getPort();
 * getHostName();
 *
 * @create 2020-05-31 10:30
 */
public class PortTest {
    public static void main(String[] args) {
        // 包含端口
        InetSocketAddress socketAddress = new InetSocketAddress("127.0.0.1",3306);
        InetSocketAddress socketAddress1 = new InetSocketAddress("localhost",4000);
        System.out.println(socketAddress.getHostName());
        // activate.navicat.com// 返回服务的名称
        System.out.println(socketAddress1.getAddress());
        // localhost/127.0.0.1：返回IP地址
        System.out.println(socketAddress1.getPort());
        // 4000：返回端口号
    }
}
```

#### URL

1. IP地址唯一表示了Internet上的计算机，而URL则标识了这些计算机上的资源。类URL代表一个统一的资源定位符，它是指向互联网“资源”的指针。资源可以是简单的文件或目录，也可以是对更为复杂的对象的引用，例如对数据库或搜索引擎的查询。

2. 为了方便程序员编程使用，JDK中提供了URL类，该类的全名是java.net.URL，有了这样一个类，就可以使用它的各种方法来对URL对象分割、合并等处理。

3. ```java
   import java.net.MalformedURLException;
   import java.net.URL;
   
   /**
    * @author 张辉
    * @Description URL :统一资源定位器，互联网的三大基石之一（URL，HTTP，HTML），区分定位资源。
    * 1. 协议
    * 2. 域名、计算机
    * 3. 端口：默认80（也就是不写的时候）
    * 4. 请求资源
    * http://www.baidu.com:80/index?uname=shsxt&age=18#a
    *
    * URL方法
    * 获取网络协议：getProtocol();
    * 获取域名或者IP：getHost();
    * 获取请求的资源（包括请求的参数）：getFile();
    * 获取请求的资源：getPath();
    * 获取请求的端口：getPort();
    * 获取请求的参数：getQuery();
    * 获取锚点：getRef();
    * @create 2020-05-31 10:42
    */
   public class URLTest01 {
       public static void main(String[] args) throws MalformedURLException {
           URL url = new URL("http://www.baidu.com:80/index?uname=shsxt&age=18#acs");
           // 获取四个值
           System.out.println("协议：" + url.getProtocol());
           System.out.println("域名|ip：" + url.getHost());
           System.out.println("请求资源1：" + url.getFile());
           System.out.println("请求资源2：" + url.getPath());
           System.out.println("请求端口：" + url.getPort());
   
           // 参数
           System.out.println("参数：" + url.getQuery());
   
           // 锚点
           System.out.println("锚点：" + url.getRef());
           
           URL u2 = new URL(url, "2.html"); // 相对路径构建url对象
       }
   }
   
   ```

4. 网络爬虫

```java
import java.io.BufferedReader;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.net.URL;

/**
 * @author 张辉
 * @Description 网络爬虫原理
 * @create 2020-05-31 11:01
 */
public class SpiderTest01 {
    public static void main(String[] args) throws Exception {
        // 获取URL
        //URL url = new URL("https://www.jd.com");
        URL url = new URL("https://www.dianping.com");
        // 下载资源
        InputStream is = url.openStream();
        BufferedReader br = new BufferedReader(new InputStreamReader(is,"UTF-8"));
        String msg = null;
        while ((msg = br.readLine()) != null) {
            System.out.println(msg);
        }
        br.close();
        // 分析
        // 筛选
    }
}


//____________________________________
import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.net.HttpURLConnection;
import java.net.URL;

/**
 * @author 张辉
 * @Description 网络爬虫原理 + 模拟浏览器
 * @create 2020-05-31 11:01
 */
public class SpiderTest02 {
    public static void main(String[] args) throws Exception {
        // 获取URL
        URL url = new URL("https://www.dianping.com");
        // 下载资源
        HttpURLConnection conn = (HttpURLConnection)url.openConnection();
        conn.setRequestMethod("GET");
        conn.setRequestProperty("User-Agent","Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/83.0.4103.61 Safari/537.36"); 
        // 这儿是在网页的request中获取的。
        BufferedReader br = new BufferedReader(new InputStreamReader(conn.getInputStream(),"UTF-8"));
        String msg = null;
        while ((msg = br.readLine()) != null) {
            System.out.println(msg);
        }
        br.close();
        // 分析
        // 筛选
    }
}
```

### 基于TCP协议的Socket编程和通信

> 在网络通讯中，第一次主动发起通讯的程序被称为客户端（Client）程序，简称客户端，而在第一次通讯中等待连接的程序被称作服务端（Server）程序，简称服务器。一但通讯简历，则客户端和服务器端完全一样，没有本质的区别。

#### “请求-响应”模式

1. Socket类：发送TCP消息。
2. ServerSocket类：创建服务器。

3. 套接字是一种进程间的数据交换的机制。这些进程既可以在同一个机器上，也可以在网络连接的不同机器上。换句话说，套接字起到通信端点的作用。单个套接字是一个端点，而一对套接字则构成一个双向通信管道，是非关联进程可以在本地或通过网络进行数据交换。一旦建立套接字连接，数据即可相同或不同的系统同中双向或单向发送，知道其中一个端点关闭连接。套集字与主机地址和端口地址相关联。主机地址就是客户端或服务器程序所在的主机的IP地址。端口地址是指客户端或服务器程序使用的主机的通讯端口。
4. 在客户端和服务器中，分别创建独立的Socket，并通过Socket的属性，将两个Socket进行连接，这样，客户端和服务器通过套接字所建立的连接使用输入输出流进行通信。
5. TCP/IP套接字是最可靠的双向流协议，使用TCP/IP 可以发送任意数量的数据。
6. 实际上，套接字只是计算机上已编号的端口。如果发送方和接收方计算机确定好端口，他们就可以通信了。

 ![图12-6 客户端与服务器端的通信关系图.png](C:\Users\张辉\Desktop\日常记录\笔记\Java学校\1495940019482522.png) 

#### TCP/IP 通信连接地简单过程

1. 位于A计算机上的TCP/IP软件向B计算机发送包含端口号的信息，B计算机的TCP/IP软件接收到该消息，并进行检查，查看它是否有它知道的程序正在该端口上接收消息。如果有，他就将该消息交给这个程序。
2. 要是程序有效地运行，就必须有一个客户端和一个服务器。

#### 通过Socket的编程顺序

1. 创建服务器ServerSocket，在创建时，定义ServerSocket的监听端口（在这个端口接收客户端发来的消息）。
2. ServerSocket调用accept()方法，使之处于阻塞状态。
3. 创建客户端Socket，并设置服务器的IP及端口。
4. 客户端发出连接请求，建立连接。
5. 分别取得服务器和客户端Socket的InputStream和OutputStream。
6. 利用Socket和ServerSocket进行数据传输。
7. 关闭流及Socket。

#### TCP双向通讯实例

```java
// ----------------------Server--------------------------
import java.io.DataInputStream;
import java.io.DataOutputStream;
import java.io.IOException;
import java.net.ServerSocket;
import java.net.Socket;

/**
 * @author 张辉
 * @Description 服务端（双向）
 * @create 2020-06-02 17:50
 */
public class LoginTwoWayServer2 {
    public static void main(String[] args) throws IOException {
        System.out.println("-----------Server---------------");
        // 1. 指定端口，使用ServerSocket创建服务器
        ServerSocket server = new ServerSocket(8888);
        // 2. 阻塞式等待
        Socket client = server.accept();
        System.out.println("一个客户端建立了连接");
        // 3. 操作输入输出流操作
        DataInputStream dis = new DataInputStream(client.getInputStream());
        // 获取通过指定端口进来的数据
        String data = dis.readUTF();
        String uname = "";
        String upassword = "";
        // 分析
        String[] dataArray = data.split("&");
        for (String info: dataArray) {
            String[] userInfo = info.split("=");
            if (userInfo[0].equals("uname")) {
                System.out.println("你的用户名：" + userInfo[1]);
                uname = userInfo[1];
            } else if (userInfo[0].equals("upassword")) {
                System.out.println("你的密码为：" + userInfo[1]);
                upassword = userInfo[1];
            }
        }
        // 输出
        DataOutputStream dos = new DataOutputStream(client.getOutputStream());
        // 通过连接将数据返回
        if (uname.equals("zhangsan") && upassword.equals("123456")) {
            // 成功
            dos.writeUTF("登陆成功！欢迎使用！");
        } else {
            // 失败
            dos.writeUTF("用户名或密码错误！");
        }
        dos.flush();
        // 4. 释放资源
        dos.close();
        dis.close();
        client.close();
    }
}

//-------------------------Client---------------------------
import java.io.*;
import java.net.Socket;

/**
 * @author 张辉
 * @Description 客户端（双向）
 * @create 2020-06-02 17:50
 */
public class LoginTwoWayClient2 {
    public static void main(String[] args) throws IOException {
        System.out.println("------------------Client----------------------");
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));

        System.out.println("请输入用户名：");
        String uname = br.readLine();
        System.out.println("请输入密码：");
        String upassword = br.readLine();
        //1. 建立连接：使用Socket创建客户端 + 服务的地址和端口
        Socket client = new Socket("localhost",8888);
        //2. 操作：输入输出流操作
        DataOutputStream dos = new DataOutputStream(client.getOutputStream());
        dos.writeUTF("uname=" + uname + "&" + "upassword=" + upassword);
        dos.flush();

        DataInputStream dis = new DataInputStream(client.getInputStream());
        String result = dis.readUTF();

        System.out.println(result);
        //3. 释放资源
        dos.close();
        client.close();
    }
}
```



### UDP通讯的实现

**DatagramSocket：用于发送或接收数据报包**

1. 当服务器要想客户端发送数据时，需要在服务器端产生一个DatagramSocket对象。服务器端的DatagramSocket将DatagramPacket发送到网络上，然后被客户端Datagramsocket接收。
2. DatagramSocket有两种常用的构造函数。一种是无需任何参数的，常用于客户端；另一种需要指定端口，常用于服务器端。如下所示：
   1. `DatagramSocket():`构造数据报套接字并将其绑定到本地主机上的任何可用的端口。
   2. `DatagramSocket(int port):`创建数据报套接字并将其绑定到本地主机上的指定端口。

**常用方法：**

+ `send(DatagramSocket p)`： 从此套接字发送数据报包。
+ `receive(DatagramPacket p)`：从此套接字接收数据报包。
+ `close()`：关闭此数据包。

**DatagramPacket：数据容器（封包）的作用**

> 此类表示数据报包，数据报包用来实现封包的功能。

**常用方法：**

+ DatagramPacket(byte[] buf, int len)：构造数据报包，用来接收长度为length的数据包。
+ DatagramPacket(byte[] buf, int length, InetAddress address, int port)：构造数据包，用来将长度为length的包发送到指定主机上的指定端口号。
+ getAddress()：获取发送或接受方计算机的IP地址，此数据包将要发往该机器或者是从该机器接收到的。
+ getData()：获取发送或接受的数据。
+ setData(byte[] buf)：设置发送的数据。

#### UDP通信变成基本步骤

1. 创建客户端的DatagramSocket，创建时，定义客户端的监听端口。
2. 创建服务器端的DatagramScoket，创建时，定义服务器的监听端口。
3. 在服务器端定义DatagramPacket对象，封装等待发送的数据包。
4. 客户端将数据报包发出去。
5. 服务端接收数据报包。

#### UDP双向通讯实例

```java
// ----------------------多线程，发送端------------------------
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.net.*;
import java.nio.Buffer;

/**
 * @author 张辉
 * @Description 多线程发送端，使用面向对象的封装
 * @create 2020-06-02 15:25
 */
public class TalkSend implements Runnable {
    private DatagramSocket client;
    private BufferedReader reader;
    private String toIP;
    private int toPort;
    public TalkSend(int port, String toIP, int toPort) {
        this.toIP = toIP;
        this.toPort = toPort;
        try {
            client = new DatagramSocket(port);
            reader = new BufferedReader(new InputStreamReader(System.in));
        } catch (SocketException e) {
            e.printStackTrace();
        }
    }


    @Override
    public void run() {
        while (true) {
            String data = null;
            try {
                data = reader.readLine();
                byte[] datas = data.getBytes();
                // 封装成DatagramPacket 包裹，需要指定目的地
                DatagramPacket packet = new DatagramPacket(datas,0,datas.length,
                        new InetSocketAddress(this.toIP,this.toPort));
                client.send(packet);
                if (data.equals("bye")) {
                    break;
                }
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
        // 释放资源
        client.close();
    }
}

// ----------------------多线程，接收端------------------------
import java.io.IOException;
import java.net.DatagramPacket;
import java.net.DatagramSocket;
import java.net.SocketException;

/**
 * @author 张辉
 * @Description 接收端，使用面向对象封装
 * @create 2020-06-02 15:26
 */
public class TalkReceive implements Runnable{
    private DatagramSocket server ;
    private String from;

    public TalkReceive(int port, String from) {
        this.from = from;
        try {
            server = new DatagramSocket(port);
        } catch (SocketException e) {
            e.printStackTrace();
        }
    }

    @Override
    public void run() {
        while (true) {
            byte[] contaienr = new byte[1024 * 60];
            DatagramPacket packet = new DatagramPacket(contaienr, 0, contaienr.length);
            try {
                server.receive(packet);
                byte[] datas = packet.getData();
                int len = packet.getLength();
                String data = new String(datas, 0 ,len);
                System.out.println(from + " --> " + data);
                if (data.equals("bye")) {
                    break;
                }
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
        server.close();
    }
}

// ----------------------使用多线程，老师端------------------------
/**
 * @author 张辉
 * @Description 加入多线程，实心双向交流，模拟在线咨询
 * @create 2020-06-02 16:24
 */
public class TalkTeacher {
    public static void main(String[] args) {
        new Thread(new TalkReceive(9999, "学生")).start();// 接收

        new Thread(new TalkSend(5555, "localhost", 8888)).start();// 发送
    }
}

// ----------------------使用多线程，学生端------------------------
/**
 * @author 张辉
 * @Description 加入多线程，实心双向交流，模拟在线咨询
 * @create 2020-06-02 16:22
 */
public class TalkStudent {
    public static void main(String[] args) {
        new Thread(new TalkSend(7777, "localhost", 9999)).start();// 发送

        new Thread(new TalkReceive(8888, "老师")).start();// 接收

    }
}
```



### 总结

1. 端口时虚拟的概念，并不是说在主机上真的有若干个端口。

2. 在www上，每一信息资源都有统一且唯一的地址，该地址就叫URL（Uniform Resorce Locator），他是www的统一资源定位符。

3. TCP与UDP的区别
   1. TCP 是面向连接的，传输数据俺去那，稳定，效率相对低。
   2. UDP是面向无连接的，传输数据不安全，效率较高。
   
4. Socket通信是一种基于TCP协议，建立稳定连接的点对点通信。

5. 网络编程是由java.net包来提供网络功能。
   1. InetAddress：封装计算机的IP地址和DNS（没有端口信息）。
   2. InetSocketAddress：包含IP和端口，常用于Socket通信。
   3. URL：以使用它的个助攻方法来对URL对象进行分割、合并等处理。
   
6. 基于TCP协议的Socket编程和通信

   1. “请求-响应”模式：

      --Socket类：发送TCP消息。

      --ServerSocket类：创建服务器。

7. UDP通讯的实现

   1. DatgramSocket：用于发送或接收数据包。
   2. 常用方法：send(),receive(),close()。

8. DatagramPacket：数据容器（封包）的作用

   1. 常用方法：构造方法、getAddress（获取发送或接收方计算机的IP地址）、getData（获取发送或接收的数据）、setData（设置发送的数据）。

### 基于TCP的聊天室

#### 流关闭工具类

```java
import java.io.Closeable;
import java.io.IOException;

/**
 * @author 张辉
 * @Description 释放资源----》工具类
 * @create 2020-06-02 22:02
 */
public class ZhUtils {
    public static void close(Closeable... targets) {
        for (Closeable target : targets) {
            try {
                if (target != null) {
                    target.close();
                }
            } catch (IOException e) {
                System.out.println("关闭流（工具类）出错");
            }
        }
    }
}
```

#### 聊天室服务端

```java
// 服务端就是接收信息，并且转发信息。

// 管理员功能：存一个表，用来存储管理员的信息，在以后的禁言和踢人中使用。

// 禁言功能：禁言就是在管理员设置了禁言之后，一段时间内，将某人的账号限制，发的消息，不向其他人转发。

// 踢人功能：直接关闭流。

import java.io.DataInputStream;
import java.io.DataOutputStream;
import java.io.IOException;
import java.net.ServerSocket;
import java.net.Socket;
import java.util.concurrent.CopyOnWriteArrayList;

/**
 * @author 张辉
 * @Description 在线聊天室：服务端
 * 版本1.0：目标：实现一个客户可以正常发消息
 * 版本1.1：目标：发送多条消息
 * 版本2.0：目标：实现多个用户发送多条消息 (问题：客户必须等待之前的客户退出，才能够使用)
 * 版本2.1：目标：使用多线程，解决2.0版本的问题（问题：线程代码太多，不好维护，客户端读写没有分开，必须先写后读）
 * 版本3.0：目标：使用oop，解决版本2.1的问题
 * 版本4.0：目标：加入容器，实现群聊
 * 版本5.0：目标：实现简单地私聊
 * @create 2020-06-02 20:54
 */
public class Chat {
    private static CopyOnWriteArrayList<Channel> all = new CopyOnWriteArrayList<Channel>();
    // CopyWiterArrayList 可以一边读一边写，（解决并发）


    public static void main(String[] args) throws IOException {
        System.out.println("-----------------Server-------------------");
        // 1. 指定端口 使用ServerSocket创建服务器
        ServerSocket server = new ServerSocket(8888);

        while (true) {
            // 2. 阻塞式等待连接 accept
            Socket client = server.accept(); // 监听端口
            System.out.println("一个客户端建立了连接");
            Channel c = new Channel(client);
            all.add(c); // 使用容器管理所有成员
            new Thread(c).start();
        }
    }

    static class Channel implements Runnable {
        private DataInputStream dis;
        private DataOutputStream dos;
        private Socket client;
        private boolean isRunning;
        private String name;

        public Channel(Socket client) {
            this.client = client;
            try {
                dis = new DataInputStream(client.getInputStream());
                dos = new DataOutputStream(client.getOutputStream());
                isRunning = true;
                // 获取名称
                name = receive();
                // 欢迎来到
                this.send("欢迎来到！");
                sendOthers(this.name + "来到了聊天室", true);
            } catch (IOException e) {
                System.out.println("初始化Channel出错");
                release();
            }
        }

        // 接收消息
        private String receive() {
            String msg = ""; // 在处理之前先进行初始化，就可以避免空指异常
            try {
                msg = dis.readUTF();
            } catch (IOException e) {
                System.out.println("接收消息receive出错");
                release();
            }
            return msg;
        }

        // 发送消息
        private void send(String msg) {
            try {
                dos.writeUTF(msg);
                dos.flush();
            } catch (IOException e) {
                System.out.println("发送消息send出错");
                release();
            }
        }

        /**
         * 群聊：获取自己的消息，发给其他人
         * 私聊：约定数据格式：@xxx:msg
         *
         * @param msg
         */
        private void sendOthers(String msg, boolean isSys) {
            boolean isPrivate = msg.startsWith("@");
            if (isPrivate) {
                // 私聊
                int idx = msg.indexOf(":"); // 返回“:”第一次出现的地方
                // 获取目标和数据
                String targetName = msg.substring(1, idx);
                msg = msg.substring(idx + 1);
                for (Channel other:all) {
                    if (other.name.equals(targetName)) {
                        // 目标找到
                        other.send(this.name + "悄悄地对你说：" + msg); // 群聊消息

                    }
                }
            } else {
                // 群聊
                for (Channel other : all) {
                    if (other == this) {
                        // 自己
                        continue;
                    }
                    if (!isSys) {
                        other.send(this.name + "说：" + msg); // 群聊消息
                    } else {
                        other.send(msg);  // 系统消息
                    }
                }
            }
        }

        // 释放资源
        private void release() {
            this.isRunning = false;
            ZhUtils.close(dos, dis, client);
            all.remove(this);
            sendOthers(this.name + "离开了大家庭！", true);
        }

        @Override
        public void run() {
            while (isRunning) {
                String msg = receive(); // 接收消息
                if (!msg.equals("")) {
                    //send(msg); // 发送消息
                    sendOthers(msg, false);
                }
            }
        }
    }
}
```

#### 聊天室客户端

```java
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.net.Socket;

/**
 * @author 张辉
 * @Description 在线聊天室：客户端
 * 版本1.0：目标：实现一个客户可以正常发消息
 * 版本1.1：目标：发送多条消息
 * 版本2.0：目标：实现多个用户发送多条消息 (问题：客户必须等待之前的客户退出，才能够使用)
 * 版本2.1：目标：使用多线程，解决2.0版本的问题（问题：线程代码太多，不好维护，客户端读写没有分开，必须先写后读）
 * 版本3.0：目标：使用oop，解决版本2.1的问题
 * 版本4.0：目标：加入容器，实现群聊
 * @create 2020-06-02 20:54
 */
public class Client {
    public static void main(String[] args) throws IOException {
        System.out.println("-----------------Client-------------------");
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        System.out.println("请输入用户名：");
        String name = br.readLine();
        // 1. 建立连接：使用Socket创建客户端 + 服务的地址和端口
        Socket client = new Socket("localhost", 8888);
        // 2. 客户端发送消息
        new Thread(new Send(client, name)).start();
        new Thread(new Receive(client)).start();

    }

}

```

##### 发送类

```java
import java.io.BufferedReader;
import java.io.DataOutputStream;
import java.io.IOException;
import java.io.InputStreamReader;
import java.net.Socket;

/**
 * @author 张辉
 * @Description 发送端：使用多线程封装了发送端
 * 1. 发送消息
 * 2. 从控制台获取消息
 * 3. 释放资源
 * 4. 重写run()
 * @create 2020-06-02 22:23
 */
public class Send implements Runnable {
    private BufferedReader console;
    private DataOutputStream dos;
    private Socket client;
    private boolean isRunning;
    private String name;

    public Send(Socket client, String name) {
        this.client = client;
        this.name = name;
        console = new BufferedReader(new InputStreamReader(System.in));
        try {
            dos = new DataOutputStream(client.getOutputStream());
            isRunning = true;
            //发送名称
            send(name);
        } catch (IOException e) {
            System.out.println("初始化Send出错");
            this.release();
        }
    }

    @Override
    public void run() {
        while (isRunning) {
            String msg = getStrFromConsole();
            if (!msg.equals("")) {
                send(msg);
            }
        }
    }

    private void send(String msg) {
        try {
            dos.writeUTF(msg);
            dos.flush();
        } catch (IOException e) {
            System.out.println("客户端发送消息send出错");
            release();
        }
    }

    /**
     * 从控制台获取消息
     * @return
     */
    private String getStrFromConsole() {
        try {
            return console.readLine();
        } catch (IOException e) {
            e.printStackTrace();
            System.out.println("从控制台获取输入出错");
        }
        return "";
    }

    private void release() {
        this.isRunning = false;
        ZhUtils.close(dos, client);
    }
}
```

##### 接收类

```java
import java.io.DataInputStream;
import java.io.IOException;
import java.net.Socket;

/**
 * @author 张辉
 * @Description 接收端：使用多线程封装了接收端
 * 1. 接收消息
 * 3. 释放资源
 * 4. 重写run()
 * @create 2020-06-02 22:23
 */
public class Receive implements Runnable {
    private DataInputStream dis ;
    private Socket client;
    private boolean isRunning;

    public Receive(Socket client) {
        this.client = client;
        try {
            dis = new DataInputStream(client.getInputStream()); // 从服务器get消息
            isRunning = true;
        } catch (IOException e) {
            System.out.println("客户端初始化Receive出错");
            release();
        }
    }

    private String receive (){
        String msg = "";
        try {
            msg = dis.readUTF();
        } catch (IOException e) {
            System.out.println("客户端接收消息receive出错");
            release();
        }
        return msg;
    }

    @Override
    public void run() {
        while (isRunning) {
            String msg = receive();
            if (!msg.equals("")) {
                System.out.println(msg);
            }
        }
    }

    private void release() {
        this.isRunning = false;
        ZhUtils.close(dis, client);
    }
}
```

## webserver

> 1. 处理Client发过来的Request的请求头以及请求正文。
> 2. 通过xml映射到类中，处理数据
> 3. 通过response 处理返回头以及返回的内容，

### 反射(Class)

> 把Java类中的各种结构（方法、属性、构造器、类名）映射成一个个的Java对象。

```java
// 获取class对象的三种方式
// 1. 对象.getClass();
Iphone iphone = new Iphone();
Class clz = iphone.getClass();
// 2. 类.class
Class clz1 = Iphone.class;
// 3. Class.forname("包名.类名")
Class clz2 = Class.forName("com.zh.server.basic.Iphone");
```

```java
// 动态创建对象
Class clz1 = Class.forName("com.zh.server.basic.Iphone");
Iphone iphone1 = (Iphone)clz1.getConstructor().newInstance();
```

### XML解析

```xml
<?xml version="1.0" encoding="utf-8"?>
<persons>
    <person>
        <name>至尊宝</name>
        <age>9000</age>
    </person>
    <person>
        <name>白晶晶</name>
        <age>7000</age>
    </person>
</persons>
```

>  SAX（simple API for XML）是一种XML解析的替代方法。相比于DOM，SAX是一种速度更快，更有效的方法。它逐行扫描文档，一边扫描一边解析。而且相比于DOM，SAX可以在解析文档的任意时刻停止解析，但任何事物都有其相反的一面，对于SAX来说就是操作复杂。 

```java
import org.xml.sax.Attributes;
import org.xml.sax.SAXException;
import org.xml.sax.helpers.DefaultHandler;

import javax.xml.parsers.ParserConfigurationException;
import javax.xml.parsers.SAXParser;
import javax.xml.parsers.SAXParserFactory;
import java.io.IOException;

/**
 * @author 张辉
 * @Description 熟悉SAX解析流程(XML：可扩展标记语言)
 * @create 2020-06-07 11:35
 */
public class XmlTest01 {
    public static void main(String[] args) throws Exception {
        //SAX解析
        //1. 获取解析工厂
        SAXParserFactory factory = SAXParserFactory.newInstance();
        //2. 从解析工厂获取解析器
        SAXParser parse = factory.newSAXParser();
        //3. 编写处理器
        //4. 加载文档Document注册处理器
        PHandler handler = new PHandler();
        //5. 解析
        parse.parse(Thread.currentThread().getContextClassLoader().getResourceAsStream("com/zh/server/basic/p.xml"), handler);
    }
}

class PHandler extends DefaultHandler { // 处理器
    @Override
    public void startDocument() throws SAXException {
        System.out.println("-------------------解析文档开始-------------------");
    }

    @Override
    public void startElement(String uri, String localName, String qName, Attributes attributes) throws SAXException {
        System.out.println(qName + "-->解析开始");
    }

    @Override
    public void characters(char[] ch, int start, int length) throws SAXException {
        // XML解析最重要的地方
        String contents = new String(ch,start,length).trim();
        if(contents.length() > 0) {
            System.out.println("内容为：" + contents);
        } else {
            System.out.println("内容为：" + "空");
        }
    }

    @Override
    public void endElement(String uri, String localName, String qName) throws SAXException {
        System.out.println(qName + "-->解析结束");
    }

    @Override
    public void endDocument() throws SAXException {
        System.out.println("-------------------------解析文档结束--------------------------");
    }
}
```

```java
看了半天，webserver我觉得就是开放一个端口，然后通过这个端口访问到服务。
serverSocket = new ServerSocket(8888);
然后等待client访问，随时进行服务响应（accept监控端口）
Socket client = serverSocket.accept();


然后进行请求信息的处理Request，Response,
接下来进行XML解析，
    
XML 解析完成之后，进行反射，反射到相应的servlet，并将处理好的Request，Response传进去，之后进行servlet中的处理。
如果没有反射到相应的servlet，那么就返回一个标准的错误页面或者数据。
    
    。。。。。处理过程优点恶心（写的时候简单，看的时候难），花了一个多小时终于把自己半月前抄的代码看懂了，还只是看懂了一部分。
```

## Annotation注解

 https://www.jianshu.com/p/9471d6bcf4cf 

### 什么是注解

1. 提供信息给编译器： 编译器可以利用注解来检测出错误或者警告信息，打印出日志。
2. 编译阶段时的处理： 软件工具可以用来利用注解信息来自动生成代码、文档或者做其它相应的自动处理。
3. 运行时处理： 某些注解可以在程序运行的时候接受代码的提取，自动做相应的操作。
4. 正如官方文档的那句话所说，注解能够提供元数据，转账例子中处理获取注解值的过程是我们开发者直接写的注解提取逻辑，**处理提取和处理 Annotation 的代码统称为 APT（Annotation Processing Tool)**。上面转账例子中的processAnnotationMoney方法就可以理解为APT工具类。

### 注解的定义

```java
public @interface MyTestAnnotation {
    
}
```

### 元注解

>  元注解顾名思义我们可以理解为注解的注解，它是作用在注解中，方便我们使用注解实现想要的功能。元注解分别有@Retention、 @Target、 @Document、 @Inherited和@Repeatable（JDK1.8加入）五种。

#### @Retention

1. Retention英文意思有保留、保持的意思，它表示注解存在阶段是保留在源码（编译期），字节码（类加载）或者运行期（JVM中运行）。在@Retention注解中使用枚举RetentionPolicy来表示注解保留时期

2. @Retention(RetentionPolicy.SOURCE)，注解仅存在于源码中，在class字节码文件中不包含
3. @Retention(RetentionPolicy.CLASS)， 默认的保留策略，注解会在class字节码文件中存在，但运行时无法获得
4. @Retention(RetentionPolicy.RUNTIME)， 注解会在class字节码文件中存在，在运行时可以通过反射获取到
5. 如果我们是自定义注解，则通过前面分析，我们自定义注解如果只存着源码中或者字节码文件中就无法发挥作用，而在运行期间能获取到注解才能实现我们目的，所以自定义注解中肯定是使用 ==@Retention(RetentionPolicy.RUNTIME)==

#### @Target

1. Target的英文意思是目标，这也很容易理解，使用@Target元注解表示我们的注解作用的范围就比较具体了，可以是类，方法，方法参数变量等，同样也是通过枚举类ElementType表达作用类型
2. @Target(ElementType.TYPE) 作用接口、类、枚举、注解
3. @Target(ElementType.FIELD) 作用属性字段、枚举的常量
4. @Target(ElementType.METHOD) 作用方法
5. @Target(ElementType.PARAMETER) 作用方法参数
6. @Target(ElementType.CONSTRUCTOR) 作用构造函数
7. @Target(ElementType.LOCAL_VARIABLE)作用局部变量
8. @Target(ElementType.ANNOTATION_TYPE)作用于注解（@Retention注解中就使用该属性）
9. @Target(ElementType.PACKAGE) 作用于包
10. @Target(ElementType.TYPE_PARAMETER) 作用于类型泛型，即泛型方法、泛型类、泛型接口 （jdk1.8加入）
11. @Target(ElementType.TYPE_USE) 类型使用.可以用于标注任意类型除了 class （jdk1.8加入）
12. 一般比较常用的是ElementType.TYPE类型

#### @Documented

>  Document的英文意思是文档。它的作用是能够将注解中的元素包含到 Javadoc 中去。 

#### @Inherited

> Inherited的英文意思是继承，但是这个继承和我们平时理解的继承大同小异，一个被@Inherited注解了的注解修饰了一个父类，如果他的子类没有被其他注解修饰，则它的子类也继承了父类的注解。 

#### @Repeatable

> Repeatable的英文意思是可重复的。顾名思义说明被这个元注解修饰的注解可以同时作用一个对象多次，但是每次作用注解又可以代表不同的含义。 

```java
/**一个人喜欢玩游戏，他喜欢玩英雄联盟，绝地求生，极品飞车，尘埃4等，则我们需要定义一个人的注解，他属性代表喜欢玩游戏集合，一个游戏注解，游戏属性代表游戏名称*/
/**玩家注解*/
@Documented
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.TYPE)
public @interface People {
    Game[] value() ;
}
/**游戏注解*/
@Repeatable(People.class)
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.TYPE)
public @interface Game {
    String value() default "";
}
/**玩游戏类*/
@Game(value = "LOL")
@Game(value = "PUBG")
@Game(value = "NFS")
@Game(value = "Dirt4")
public class PlayGame {
}
```

### 注解的属性

> 注解的属性其实和类中定义的变量有异曲同工之处，只是注解中的变量都是成员变量（属性），并且注解中是没有方法的，只有成员变量，变量名就是使用注解括号中对应的参数名，变量返回值注解括号中对应参数类型。相信这会你应该会对上面的例子有一个更深的认识。而@Repeatable注解中的变量则类型则是对应Annotation（接口）的泛型Class。

```java
/**注解Repeatable源码*/
@Documented
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.ANNOTATION_TYPE)
public @interface Repeatable {
    /**
     * Indicates the <em>containing annotation type</em> for the
     * repeatable annotation type.
     * @return the containing annotation type
     */
    Class<? extends Annotation> value();
}
```

### 注解的本质

>  注解的本质就是一个Annotation接口 

```java
/**Annotation接口源码*/
public interface Annotation {

    boolean equals(Object obj);

    int hashCode();

    Class<? extends Annotation> annotationType();
}
```

### 注解成员变量赋值

```java
@Documented
@Inherited
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.TYPE)
public @interface MyTestAnnotation {
    String name() default "mao";
    int age() default 18;
}

@MyTestAnnotation(name = "father",age = 50)
public class Father {
}
```

### 使用反射获取注解的信息

```java
//---------------------MyFiled注解-----------------------
import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;

/**
 * @author 张辉
 * @Description MyFiled注解
 * @create 2020-06-27 10:30
 */
@Target(value = {ElementType.FIELD})
@Retention(RetentionPolicy.RUNTIME)
public @interface MyFiled {
    String columnName();
    String type();
    int length();
}

//---------------------MyTable注解-----------------------
import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;

/**
 * @author 张辉
 * @Description MyTable注解
 * @create 2020-06-27 10:16
 */
@Target(value = {ElementType.TYPE})
@Retention(RetentionPolicy.RUNTIME)
public @interface MyTable {
    String value();
}


//---------------------使用注解-----------------------
/**
 * @author 张辉
 * @Description
 * @create 2020-06-27 10:15
 */
@MyTable(value = "tb_student")
public class MyStudent {
    @MyFiled(columnName = "id",type = "int",length = 3)
    private int id;

    @MyFiled(columnName = "sname",type = "varchar",length = 10)
    private String studentName;

    @MyFiled(columnName = "age",type = "int",length = 10)
    private int age;

    public int getId() {
        return id;
    }

    public void setId(int id) {
        this.id = id;
    }

    public String getStudentName() {
        return studentName;
    }

    public void setStudentName(String studentName) {
        this.studentName = studentName;
    }

    public int getAge() {
        return age;
    }

    public void setAge(int age) {
        this.age = age;
    }
}

//---------------------使用反射获取注解-----------------------
import java.lang.annotation.Annotation;
import java.lang.reflect.Field;

/**
 * @author 张辉
 * @Description 使用反射读取注解的信息，模拟处理注解信息的流程
 * @create 2020-06-27 10:36
 */
public class Demo03 {

    public static void main(String[] args) {
        try {
            Class clazz = Class.forName("TestAnnotation.MyStudent");

            // 获得类的所有有效注解
            Annotation[] annotations = clazz.getAnnotations();
            for (Annotation a : annotations) {
                System.out.println(a);
            }

            // 获取类指定的注解
            MyTable mt = (MyTable) clazz.getAnnotation(MyTable.class);
            System.out.println(mt);

            // 获得类的属性的注解
            Field f = clazz.getDeclaredField("studentName");
            MyFiled myFiled = f.getAnnotation(MyFiled.class);
            System.out.println(myFiled.columnName() + "---" + myFiled.type() + "---" + myFiled.length());

            // 根据获取的表名、字段的信息，拼出DDL语句，然后使用JDBC 执行这个SQL，在数据库中生成相应的表。

        } catch (Exception e) {
            e.printStackTrace();
        }
    }

}
```

## 反射

### javabean

1. 所有的类必须声明为public class，这样才能够被外部所访问；
2. 类中所有的属性都必须封装，即：使用private声明；
3. 封装的属性如果需要被外部所操作，则必须编写对应的setter、getter方法；
4. 一个JavaBean中至少存在一个无参构造方法。

```java
// javabean实例
public class User {
    private int id;
    private int age;
    private String uname;

    public int getId() {
        return id;
    }

    public void setId(int id) {
        this.id = id;
    }

    public int getAge() {
        return age;
    }

    public void setAge(int age) {
        this.age = age;
    }

    public String getUname() {
        return uname;
    }

    public void setUname(String uname) {
        this.uname = uname;
    }

    public User(int id, int age, String uname) {
        this.id = id;
        this.age = age;
        this.uname = uname;
    }

    // javabean必须有无参构造器
    public User() {

    }
}
```

### 对象的获取方式

1. ==Class<?> clazz = Class.forName("testReflection.bean.User");==
2. ==Class clazz2 = String.class;==
3. ==Class strClazz2 = path.getClass();== path为一个String型的

```java
@SuppressWarnings("all")
public class Demo01 {
    public static void main(String[] args) {
        String path = "testReflection.bean.User";

        try {
            Class<?> clazz = Class.forName(path);
            // 对象是表示或封装一些数据，一个类被加载后，JVM会创建一个对应的该类的Class对象，整个类的结构信息会放到对应的Class对象中。
            // 这个Class对象爱过你就像一面镜子一样，通过这面镜子我可以看到对应类的全部信息。
            System.out.println(clazz.hashCode());

            Class clazz2 = Class.forName(path); // 一个类只对应一个Class对象。

            Class strClazz = String.class;
            Class strClazz2 = path.getClass();
            System.out.println(strClazz==strClazz2); // 他俩是相等的，因为JVM会为对应的一个该类的Class对象，因为他俩都是String，所以就相等

            Class intClazz = int.class;

            int[] arr01 = new int[10];
            int[][] arr02 = new int[30][];
            int[] arr03 = new int[30];
            // 俩对象数组是否相等，决定因素是维数。
            System.out.println(arr01.getClass().hashCode());
            System.out.println(arr02.getClass().hashCode());
            System.out.println(arr03.getClass().hashCode());

        } catch (ClassNotFoundException e) {
            e.printStackTrace();
        }
    }
}

```

+ 对象是表示或封装一些数据，一个类被加载后，JVM会创建一个对应的该类的Class对象，整个类的结构信息会放到对应的Class对象中。
+ 这个Class对象就像一面镜子一样，通过这面镜子我可以看到对应类的全部信息。

### 使用反射API，获取类的信息

```java
@SuppressWarnings("all")
public class Demo02 {
    public static void main(String[] args) {
        String path = "testReflection.bean.User";
        try {
            Class clazz = Class.forName(path);
            System.out.println(clazz);

            // 获取类的名称
            System.out.println(clazz.getName()); // 获取包名+类名：testReflection.bean.User
            System.out.println(clazz.getSimpleName()); // 获取类名：User

            // 获取属性信息
            //Field[]  fields = clazz.getFields(); // 只能获得public的field
            Field[] fields = clazz.getDeclaredFields(); // 获得所有的Field
            Field f = clazz.getDeclaredField("uname"); // 通过指定名称获取属性
            System.out.println(f);
            System.out.println(fields.length);
            for (Field tmp : fields) {
                System.out.println("属性:" + tmp);
            }

            // 获取方法信息
            Method[] methods = clazz.getDeclaredMethods(); // 获取全部方法
            Method m01 = clazz.getDeclaredMethod("getUname", null);
            Method m02 = clazz.getDeclaredMethod("setUname", String.class);
            // 如果方法有参，则必须传递参数类型对应的class对象
            System.out.println(m02);
            for (Method m : methods) {
                System.out.println("方法：" + m);
            }

            // 获取构造器信息
            Constructor[] constructors = clazz.getDeclaredConstructors();
            Constructor c = clazz.getDeclaredConstructor(int.class,int.class,String.class);
            System.out.println("获得构造器：" + c);
            for (Constructor constructor : constructors) {
                System.out.println("构造器：" + constructor);
            }

        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}
```

### 通过反射动态操作

> 通过反射动态操作：构造器、方法、属性

```java
@SuppressWarnings("all")
public class Demo03 {
    public static void main(String[] args) {
        String path = "testReflection.bean.User";
        try {
            Class<User> clazz = (Class<User>) Class.forName(path);

            // 1. 通过反射API调用构造方法，构造对象
            User u = clazz.newInstance(); // 其实调用了User的无参构造器
            System.out.println(u);

            Constructor<User> c = clazz.getDeclaredConstructor(int.class,int.class,String.class); // 构造，
            User u2 = c.newInstance(1001,18,"张三"); // 传递参数
            System.out.println(u2.getUname());

            // 2. 通过反射API调用普通方法
            User u3 = clazz.newInstance();
            Method method = clazz.getDeclaredMethod("setUname", String.class); // 获取methods
            method.invoke(u3,"张三");
            // 上面两行就相当于实现了  u3.setUname("张三");
            System.out.println(u3.getUname());

            // 3. 通过反射API操作属性
            User u4 = clazz.newInstance();
            Field f = clazz.getDeclaredField("uname");
            f.setAccessible(true); // 这个属性不需要作安全检查了，可以直接访问
            f.set(u4,"张三4"); // 通过反射直接写属性
            System.out.println(u4.getUname()); // 通过反射直接读属性的值
            System.out.println(f.get(u4)); // 通过反射直接读属性的值

        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}

```

## 动态编译

```java
public static void main(String[] args) throws IOException {

    // 通过IO流操作，将字符串存储成一个临时文件（Hi.java），然后调用动态编译的方法！
    String str = "public class Hi {public static void main(String args[]){System.out.println(\"测试动态编译\")}}";

    JavaCompiler compiler = ToolProvider.getSystemJavaCompiler();
    int result = compiler.run(null, null, null, "C:/myjava/HelloWorld.java");
    System.out.println(result == 0 ? "编译成功" : "编译失败");

    // 动态运行编译好的类，通过Runtime.getRuntime()运行启动新的进程运行
    Runtime run = Runtime.getRuntime();
    Process process = run.exec("java -cp C:/myjava  HelloWorld");
    InputStream in = process.getInputStream();
    BufferedReader reader = new BufferedReader(new InputStreamReader(in));
    String info = "";
    while ((info = reader.readLine()) != null) {
        System.out.println(info);
    }

    try {
        URL[] urls = new URL[]{new URL("file:/" + "C:/myjava/")};
        URLClassLoader loader = new URLClassLoader(urls);
        Class c = loader.loadClass("HelloWorld");
        // 调用加载类的main方法
        Method m = c.getMethod("main",String[].class);
        m.invoke(null, (Object)new String[]{"aa", "bb"});
        // 由于可变参数时JDK5.0之后才有的。上边代码会编译成：m.invoke(null, "aa", "bb"); 就发生了参数个数不匹配的问题。
        // 因此，必须要加上(Object)转型，避免这个问题。
        // public static void mmm(String[] a,String[] b)
        // public static void main(String[] args)

    } catch (Exception e) {
        e.printStackTrace();
    }
}
```

1. 动态编译文件
   + `JavaCompiler compiler = ToolProvider.getSystemJavaCompiler();`
   + `int result = compiler.run(null, null, null, "C:/myjava/HelloWorld.java");`
   + 动态编译java文件为class文件，==.run==方法执行返回0，执行成功，其他，执行失败！
2. 动态运行编译好的类
   + `Runtime run = Runtime.getRuntime();`
   + `Process process = run.exec(java -cp C:/myjava HelloWorld);`
   + `InputStream in = process.getInputStream();`
   + `BufferedReader reader = new BufferedReader(new InputStreamReader(in));`
   + 动态运行编译好的类，通过Runtime.getRuntime()运行启动新的进程
   + 通过流读出来的就是我们动态编译运行的类的结果。
3. 动态编译字符串
   +  通过IO流操作，将字符串存储成一个临时文件（Hi.java），然后调用动态编译的方法！
   + String str = "public class Hi {public static void main(String args[]){System.out.println(\"测试动态编译\")}}";

## 脚本引擎执行js代码

```java
public static void main(String[] args) throws Exception {
    // 获得脚本引擎对象
    ScriptEngineManager sem = new ScriptEngineManager();
    ScriptEngine engine = sem.getEngineByName("javascript");

    // 定义变量，存储到引擎上下文中，
    engine.put("msg", "zhangsan is a good man!"); // 存储键值对
    String str = "var user = {name: 'zhangsan', age:19, schools: ['清华大学','北京大学']};";
    str += "print(user.name)";

    // 执行脚本
    engine.eval(str); // 输出"zhangsan"
    engine.eval("msg = 'zhangsan is a good man';");
    System.out.println(engine.get("msg"));
    System.out.println("##############################");


    // 定义js函数
    engine.eval("function add(a,b) {var sum = a + b; return sum;}");
     // 取得调用接口
    Invocable jsInvoke = (Invocable)engine;
    // 执行js脚本中定义的方法
    Object result = jsInvoke.invokeFunction("add", new Object[]{10,29});
    System.out.println(result);

}
```

+ 首先获取脚本引擎对象
+ 对脚本引擎中存储对象
+ 执行脚本

## java字节码

### 使用javassist创建一个Java类

```java
public static void main(String[] args) throws Exception {
    ClassPool pool = ClassPool.getDefault(); // 获取到类加载器
    CtClass cc = pool.makeClass("testJavassist.bean.Emp"); // 这儿就是一个文件路径吧！

    // 创建属性
    CtField f1 = CtField.make("private int empno;", cc);
    CtField f2 = CtField.make("private String ename;", cc);
    cc.addField(f1);
    cc.addField(f2);

    // 创建方法
    CtMethod m1 = CtMethod.make("public int getEmpno() {return empno;}", cc);
    CtMethod m2 = CtMethod.make("public void setEmpno(int empno) {this.empno = empno;}", cc);
    cc.addMethod(m1);
    cc.addMethod(m2);

    // 添加构造器
    CtConstructor constructor = new CtConstructor(new CtClass[]{CtClass.intType, pool.get("java.lang.String")}, cc);
    constructor.setBody("{this.empno = empno;this.ename = ename;}");
    cc.addConstructor(constructor);

    cc.writeFile("c:/myjava"); // 将上边构造好的类写入到C:/myjava
    System.out.println("生成成功！");
}
```

这儿生成的类为一个class文件

### 测试javassistAPI

#### 处理类的基本用法

```java
public static void test01() throws Exception {
    ClassPool pool = ClassPool.getDefault();
    CtClass cc = pool.get("testJavassist.Emp"); // 获取这个java文件
    byte[] bytes = cc.toBytecode();
    System.out.println(Arrays.toString(bytes));

    System.out.println(cc.getName()); // 获取类名
    System.out.println(cc.getSimpleName()); // 获取简要类名
    System.out.println(cc.getSuperclass()); // 获取父类
    System.out.println(cc.getInterfaces()); // 获取接口
}
```

####  产生新的方法

```java
public static void test02() throws Exception {
    ClassPool pool = ClassPool.getDefault();
    CtClass cc = pool.get("testJavassist.Emp");

    //CtMethod m = CtNewMethod.make("public int add(int a,int b) {return a + b;}", cc);

    CtMethod m = new CtMethod(CtClass.intType, "add", new CtClass[]{CtClass.intType, CtClass.intType}, cc);
    m.setModifiers(Modifier.PUBLIC);
    m.setBody("{System.out.println(\"cccc\");return $1 + $2;}");
    // 以上为两种创建方法的方法
    // 第二种方法要注意的是，我们在声明传入变量的时候我们并没有明确变量名，所以需要参考javassit文档，第一个参数用$1,第二个用$2
    
    cc.addMethod(m);


    // 通过反射调用新生成的方法
    Class clazz = cc.toClass();
    Object obj = clazz.newInstance(); // 通过调用Emp无参构造器，创建新的Emp对象
    Method method = clazz.getDeclaredMethod("add", int.class, int.class);
    Object result = method.invoke(obj, 100, 200);
    System.out.println(result);
}
```

#### 修改已有方法

```java
public static void test03() throws Exception {
    ClassPool pool = ClassPool.getDefault();
    CtClass cc = pool.get("testJavassist.Emp");

    CtMethod cm = cc.getDeclaredMethod("sayHello", new CtClass[]{CtClass.intType});
    cm.insertBefore("System.out.println($1);System.out.println(\"start!!\");");
    cm.insertAfter("System.out.println(\"end!!\");");
    cm.insertAt(38, "int b = 3;System.out.println(\"b=\" + b);");


    // 通过反射调用新生成的方法
    Class clazz = cc.toClass();
    Object obj = clazz.newInstance(); // 通过调用Emp无参构造器，创建新的Emp对象
    Method method = clazz.getDeclaredMethod("sayHello", int.class);
    Object result = method.invoke(obj, 10);
    System.out.println(result);
}
```

+ 这儿主要是`.insertBefore和.insertAfter和.insertAt`
+ 通过上面的方法可以在方法体的不同位置添加不同的语句。

#### 属性的get/set操作

```java
public static void test04() throws Exception {
    ClassPool pool = ClassPool.getDefault();
    CtClass cc = pool.get("testJavassist.Emp");

    // 创建新的属性
    //CtField f1 = CtField.make("private int empno;", cc);
    CtField f1 = new CtField(CtClass.intType, "salary", cc);
    f1.setModifiers(Modifier.PRIVATE);
    cc.addField(f1, "1000"); // 默认为1000

    //cc.getDeclaredField("ename"); // 获取指定的属性

    // 增加相应的set和get方法
    cc.addMethod(CtNewMethod.getter("setSalary",f1));
    cc.addMethod(CtNewMethod.getter("getSalary",f1));
}
```

#### 构造器方法操作

```java
public static void test05() throws Exception {
    ClassPool pool = ClassPool.getDefault();
    CtClass cc = pool.get("testJavassist.Emp");

    CtConstructor[] cs = cc.getConstructors();
    for(CtConstructor c: cs) {
        System.out.println(c.getLongName());
        c.insertAfter("");
    }
}
```

#### 获取注解

```java
public static void test06() throws Exception {
    CtClass cc = ClassPool.getDefault().get("testJavassist.Emp");
    Object[] all = cc.getAnnotations();
    Auther a = (Auther)all[0];
    String name = a.name();
    int year = a.year();
    System.out.println("name:" + name + ",year:" + year);
}
```

## 23种设计模式

### 单例模式

#### 饿汉式

 （线程安全，调用效率高，但是不能延时加载）

```java
public class HungrySingleton {
    private static HungrySingleton instance = new HungrySingleton();
    // 类初始化时，立即加载这个对象！加载类时，天然时线程安全的。

    private HungrySingleton() {

    }

    // 方法没有同步，调用效率高
    public static HungrySingleton getInstance() {
        return instance;
    }

}
```

#### 懒汉式

 （线程安全，调用效率不高，但是，可以延时加载）

```java
public class LazySingleton {
    private static LazySingleton instance;
    //类初始化时，不初始化这个对象（延时加载，真正用的时候才去创建）

    private LazySingleton() {
    }

    public static synchronized LazySingleton getInstance() {
        if(instance == null) {
            instance = new LazySingleton();
        }
        return instance;
    }
}

```

#### 双重检测锁式

（由于JVM底层内部模型的原因，偶尔会出现问题，所以不推荐使用）

```java
public class LockSingleton {
    private volatile static LockSingleton instance;

    private LockSingleton() {

    }

    public static LockSingleton getInstance() {
        if (instance == null) {
            synchronized (LockSingleton.class) {
                if (instance == null) {
                    instance = new LockSingleton();
                }
            }
        }
        return instance;
    }

}
```

#### 静态内部类式

（线程安全，调用效率高，但是，可以延时加载）

```java
public class InternalSingleton {
    private static class SingletonHolder {
        private static final InternalSingleton INSTANCE = new InternalSingleton();
    }

    private InternalSingleton() {

    }

    public static InternalSingleton getInstance() {
        return SingletonHolder.INSTANCE;
    }
}
```

#### 枚举式

（线程安全，调用效率高，不能延时加载，天然防止反射和序列化）

```java
public enum EnumSingleton {
    INSTANCE;

    public void doSomeThing() {

    }
}
```

#### 防范反射和反序列化破解

```java
public class SingletonDemo06 implements Serializable {
    private static SingletonDemo06 instance;
    //类初始化时，不初始化这个对象（延时加载，真正用的时候才去创建）

    private SingletonDemo06() {
        if (instance != null) { // 用来防止反射
            throw new RuntimeException();
        }
    }

    public static synchronized SingletonDemo06 getInstance() {
        if(instance == null) {
            instance = new SingletonDemo06();
        }
        return instance;
    }

    // 反序列化时，如果定义了readResolve()则直接返回此方法指定的对象。而不需要单独再创建新的对象！
    private Object readResolve() throws ObjectStreamException {
        return instance;
    }
}
```

反射和反序列化的破解方法

```java
public class Client {

    public static void main(String[] args) throws Exception {
        SingletonDemo06 s1 = SingletonDemo06.getInstance();
        SingletonDemo06 s2 = SingletonDemo06.getInstance();

        System.out.println(s1);
        System.out.println(s2);

        // 通过反射方式直接调用私有构造器
        //Class<SingletonDemo06> clazz = (Class<SingletonDemo06>) Class.forName("gof23.singleton.SingletonDemo06");
        //Constructor<SingletonDemo06> c = clazz.getDeclaredConstructor(null);
        //c.setAccessible(true); // 解除权限封锁
        //SingletonDemo06 s3 = c.newInstance();
        //SingletonDemo06 s4 = c.newInstance();
        //System.out.println(s3);
        //System.out.println(s4);

        // 通过反射序列化（Serializable）的方式构造多个对象
        FileOutputStream fos = new FileOutputStream("d:/a.txt");
        ObjectOutputStream oos = new ObjectOutputStream(fos);
        oos.writeObject(s1);
        oos.close();
        fos.close();

        ObjectInputStream ois = new ObjectInputStream(new FileInputStream("D:/a.txt"));
        SingletonDemo06 s3 = (SingletonDemo06)ois.readObject();
        ois.close();
        System.out.println(s3);

    }
}
```

#### 单例模式的性能

| 单例模式名称 | 效率测试花费时间 |
| ------------ | ---------------- |
| 懒汉式       | 303              |
| 饿汉式       | 226              |
| 静态内部类式 | 332              |
| 枚举式       | 152              |
| 双重检查锁式 | 162              |

单例对象占用资源**少**，**不需要**延时加载：枚举式好于饿汉式

单例对象占用资源**大**，**需要**延时加载：静态内部类好于懒汉式



#### **CountDownLatch**

1. 同步辅助类，在完成一组正在其他线程中执行的操作之前，它允许一个或者多个线程一直等待
2. **countDown()**当前线程调此方法，则计数器减一（建议放在finally里边执行）
3. **await()**，调用此方法会一直阻塞当前线程，直到计时器的值为0。

```java
public class Client2 {
    public static void main(String[] args) throws Exception {
        long start = System.currentTimeMillis();
        int threadNum = 100;
        final CountDownLatch countDownLatch = new CountDownLatch(threadNum);
        // 设置线程计数器，（由于变量作用域的问题，所以需要声明为final变量）

        for (int j = 0; j < threadNum; j++) {
            new Thread(new Runnable() {
                @Override
                public void run() {
                    for (int i = 0; i < 100000; i++) {
                        Object o = LazySingleton.getInstance();
                    }
                    countDownLatch.countDown();
                    // 线程计数器减一
                }
            }).start();
        }

        countDownLatch.await(); // main线程阻塞，直到计数器变为0，才会继续往下执行
        // 在这儿要注意时await，不是wait

        // 可以在这儿一直检测线程有没有执行完，也就是监测线程是否存活

        long end = System.currentTimeMillis();
        System.out.println("总耗时：" + (end - start));

    }
}
```

### 工厂模式

> 实际中使用简单工厂模式

#### 面向对象设计的基本原则

1. OCP（开闭原则，Open-Closed Principle）：一个软件的实体应当对扩展开放，对修改关闭；也就是说，不要修改原来的类，创建新的类实现新的功能。
2. DIP（依赖倒转原则，Dependence Inversion Principle）：要针对接口编程，不要针对实现编程
3. LoD（迪米特法则，Law of Demeter）：只与你直接的朋友通讯，而避免和陌生人通信。

#### 简单工厂模式

> 用来生产统一等级结构中的任意产品。（对于增加新的产品，只需要修改已有的代码）

1. 静态工厂模式（别称）
2. 虽然某种程度不符合设计原则，但实际使用最多。

```java
public class CarFactory {
    public static Car createCar(String type) {
        if ("奥迪".equals(type)) {
            return new Audi();
        } else if ("比亚迪".equals(type)) {
            return new Byd();
        } else {
            return null;
        }
    }
}
```

![image-20200730142620366](C:\Users\张辉\Desktop\gits\Java\Java300集\笔记.assets\image-20200730142620366.png)

#### 工厂方法模式

> 用来生产同一等级结构中的固定产品。（支持增加任意产品）

1. 不修改已有类的前提下，通过增加新的工厂实现拓展

```java
public class Client {
    public static void main(String[] args) {
        Car c1 = new AudiFactory().createCar();
        Car c2 = new BydFactory().createCar();
        Car c3 = new BenzFactory().createCar();
        c1.run();
        c2.run();
        c3.run();
    }
}
```

![image-20200730142522681](C:\Users\张辉\Desktop\gits\Java\Java300集\笔记.assets\image-20200730142522681.png)

#### 抽象工厂模式

> 用来生产不同产品族的全部产品。（对于增加新的产品，无能为力；支持增加产品簇）

1. 不可以增加产品，可以增加新的产品族！



![image-20200730142926160](C:\Users\张辉\Desktop\gits\Java\Java300集\笔记.assets\image-20200730142926160.png)

### 建造者模式

> 本质：分离了对象子组件的单独构造（由Builder来负责）和装配（由Director负责）。从而可以构造出复杂的对象。这个模式适用于：某个对象的构建过程复杂的情况下使用。
>
> 由于实现了构建和装配的解耦。不同的构建起，相同的装配，也可以做出不同的对象；相同的构建起，不同的装配顺序也可以做出不同的对象。也就是实现了构造算法、装配算法的解耦，实现了更好的复用。

![image-20200730222111490](C:\Users\张辉\Desktop\gits\Java\Java300集\笔记.assets\image-20200730222111490.png)

### 原型模式(prototype)

1. 通过new产生一个对象需要非常繁琐的数据准备或访问权限，则可以使用原型模式
2. 原型模式就是Java中的一种克隆技术，以某个对象为原型，复制出新的对象。显然，新的对象爱过你具备原型对象的特点
3. 原型模式的优势，效率高，直接克隆，避免了重新构造过程步骤。
4. 克隆类似于new，但是不同与new。new创建新的对象属性采用默认值。克隆出的对象的属性值完全和原型对象相同。并且克隆出的新对象改变不会影响圆形对象。然后，再修改克隆对象的值。
5. 原型模式实现**Cloneable**接口和clone方法
6. Prototype模式中实现起来最困难的地方就是内存赋值操作，所幸再Java中提供了clone()方法替我们做了绝大部分事情。

```java
public class Sheep implements Cloneable, Serializable {
    // 序列化和反序列化必须实现Serializable接口，实现复制必须有Cloneable接口
    // 浅克隆

    // 克隆
    private String name;
    private Date birthday;

    @Override
    protected Object clone() throws CloneNotSupportedException {
        Object obj = super.clone(); // 直接调用Object 对象的克隆方法（clone()）

        return obj;
    }

    public Sheep(String name, Date birthday) {
        this.name = name;
        this.birthday = birthday;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public Date getBirthday() {
        return birthday;
    }

    public void setBirthday(Date birthday) {
        this.birthday = birthday;
    }
}


//#############################################
public class Sheep2 implements Cloneable{
    // 深克隆
    private String name;
    private Date birthday;

    @Override
    protected Object clone() throws CloneNotSupportedException {
        Object obj = super.clone(); // 直接调用Object 对象的克隆方法（clone()）

        // 添加如下代码，实现深克隆
        Sheep2 s = (Sheep2) obj;
        s.birthday = (Date) this.birthday.clone(); // 把属性也进行克隆！

        return obj;
    }

    public Sheep2(String name, Date birthday) {
        this.name = name;
        this.birthday = birthday;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public Date getBirthday() {
        return birthday;
    }

    public void setBirthday(Date birthday) {
        this.birthday = birthday;
    }
}


// ###################################
public class Client3 {
    public static void main(String[] args) throws Exception {
        // 使用序列化和反序列化实现深度克隆
        Date d = new Date(1231414124124L);
        Sheep s1 = new Sheep("少理", d);
        System.out.println(s1);
        System.out.println(s1.getName());
        System.out.println(s1.getBirthday());

        // Sheep s2 = (Sheep) s1.clone(); // s2的对象是一个新的对象
        // 使用序列化和反序列化实现深复制
        ByteArrayOutputStream bos = new ByteArrayOutputStream();
        ObjectOutputStream oos = new ObjectOutputStream(bos);
        oos.writeObject(s1);
        byte[] bytes = bos.toByteArray();


        ByteArrayInputStream bis = new ByteArrayInputStream(bytes);
        ObjectInputStream ois = new ObjectInputStream(bis);
        Sheep s2 = (Sheep) ois.readObject();


        System.out.println("修改原型对象的属性值");
        d.setTime(1541412451510L);
        System.out.println(s1.getBirthday());
        s2.setName("多利");
        System.out.println(s2);
        System.out.println(s2.getName());
        System.out.println(s2.getBirthday());
    }
}
```



### 适配器模式(adapter)

1. 适配器模式就是相当于一个**高清转化线**，通过一个中间节点将两个不能连接在一块儿的东西连到一块儿。

![image-20200730223144529](C:\Users\张辉\Desktop\gits\Java\Java300集\笔记.assets\image-20200730223144529.png)

### 代理模式(proxy)

#### 静态代理模式

1. 通过代理来办理不重要的业务，你来办理重要的业务。
2. 就比如明星的经纪人，明星主要负责主要的工作，代理负责周改变的事物。

#### 动态代理模式

1. 动态代理模式就不是只能代理一个人的了，而是一个公司，给很多艺人提供代理（艺人干的事情大体类似），艺人只需要提供它的姓名，然后公司还是可以做出相应的反应。

```java
public class RealStar implements Star {
    @Override
    public void confer() {
        System.out.println("RealStar.confer");
    }

    @Override
    public void signContract() {
        System.out.println("RealStar.signContract");
    }

    @Override
    public void bookTicker() {
        System.out.println("RealStar.bookTicker");
    }

    @Override
    public void sing() {
        System.out.println("RealStar.sing");
    }

    @Override
    public void collectMoney() {
        System.out.println("RealStar.collectMoney");
    }
}
interface Star {
    void confer(); // 面谈
    void signContract(); // 签合同
    void bookTicker(); // 订票
    void sing(); // 唱歌
    void collectMoney(); // 尾款
}

// ###############################
public class StarHandler implements InvocationHandler {

    private Star realStar;

    public StarHandler(Star realStar) {
        this.realStar = realStar;
    }

    @Override
    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
        Object object = null;
        System.out.println("真正的方法执行");
        System.out.println("面谈，签合同，等等");
        if (method.getName().equals("sing")) {
            object = method.invoke(realStar, args);
        }
        System.out.println("处理结束");
        return null;
    }
}


// ####################################

public class Client {
    public static void main(String[] args) {
        Star realStar = new RealStar();
        StarHandler handler = new StarHandler(realStar);

        Star proxy = (Star) Proxy.newProxyInstance(ClassLoader.getSystemClassLoader(),
                new Class[]{Star.class}, handler);

        proxy.sing();
    }
}

```



### 桥接模式(bridge)

1. 桥接模式可以取代多层继承的方案，多层继承违背了单一职责原则，复用性较差，类的个数也非常多。桥接模式可以极大地减少子类的个数，从而降低管理和维护的成本。
2. 桥接模式极大的提高了系统可扩展性，在两个变化维度中任意扩展一个维度，都不需要修改原有的系统，符合开闭原则
3. 就比如说电脑：电脑有品牌和类型（dell，lenovo，台式机，笔记本）
   1. 你只需要让类型实现品牌的接口，然后就可以简单的改变一维，实现全部的改变
   2. 不用全局改变。

```java
public class Computer2 {

    /**
     * 这是桥接模式最重要的部分
     * 就是在一个类中把另外一个类当成一个属性加入进去
     */

    protected Brand brand;

    public Computer2(Brand brand) {
        this.brand = brand;
    }

    public void sale() {
        brand.sale();
    }
}

class Desktop2 extends Computer2 {

    public Desktop2(Brand brand) {
        super(brand);
    }

    @Override
    public void sale() {
        super.sale();
        System.out.println("Desktop2.sale");
    }
}

class Laptop2 extends Computer2 {

    public Laptop2(Brand brand) {
        super(brand);
    }

    @Override
    public void sale() {
        super.sale();
        System.out.println("Laptop2.sale");
    }
}
// ###############################
public interface Brand {
    void sale();
}

class Lenovo implements Brand{
    @Override
    public void sale() {
        System.out.println("Lenovo.sale");
    }
}

class Dell implements Brand {
    @Override
    public void sale() {
        System.out.println("Dell.sale");
    }
}

class Shenzhou implements Brand {
    @Override
    public void sale() {
        System.out.println("Shenzhou.sale");
    }
}
// ###########################
public static void main(String[] args) {
    // 销售联想笔记本电脑
    Computer2 c = new Laptop2(new Lenovo());

    c.sale();

    Computer2 c2 = new Desktop2(new Shenzhou());
    c2.sale();
}
```



### 组合模式(composite)

1. 使用组合模式的场景：
   + 把部分和整体的关系哟个属性结构来表示，从而使客户端可以使用统一的方式处理部分对象和整体对象。
2. 组合模式的核心：
   + 抽象构建（component）角色：定义了叶子和容器构件的共同点
   + 叶子（Leaf）构建角色：无子节点
   + 容器（Composite）构建角色：有容器的特征，可以包含子节点
3. 就像文件和文件夹的关系，也就是实现了遍历，通过不同的类型处理。

### 装饰模式(decorator)

1. 总结：
   + 装饰模式（Decorator）也叫包装器模式（Wrapper）
   + 装饰模式降低系统的耦合度，可以动态的增加或删除对象的职责，并使得需要装饰的具体构建类和具体装饰类可以独立变化，以便增加新的具体构建类和具体装饰类。
2. 优点：
   + 扩展对象功能，比继承灵活，不会导致类个数急剧增加
   + 可以对一个对象进行多次装饰，创造出不同行为的组合，得到功能更加强大的对象
   + 具体构建类和具体装饰类可以独立变化，用户可以根据自己增加新的具体构建子类和具体装饰子类。
3. 缺点：
   + 产生很多小对象。大量小对象占据内存，一定程度上影响性能。
   + 装饰模式易出错，调试排查比较麻烦
4. 装饰器模式就是将功能细分化，就比如说一套餐具，我们使用的时候再组合，这样就可以降低耦合。

### 外观模式(facade)

1. 为子系统提供统一的入口，封装子系统的复杂性，便于客户端调用。
2. 比如：我要造汽车，然后我只需要发布这个命令，后面怎么实现由接收你命令的这个人去实现，不用我们来处理。也就是说处理我们命令的那个人就行当与这个外观模式，也就是这个人负责了里边细节的实现。

### 享元模式(FlyWeight)

1. 场景：
   + 内存属于稀缺资源，不要随便浪费，如果有多个完全相同或相似的对象，我们可以通过享元模式，节省内存
2. 核心：
   + 享元模式以共享的方式高效的支持大量细粒度对象的重用。
   + 享元对象能做到共享的关键式区分了内部状态和外部状态
     + 内部状态：可以共享，不会随环境变化而改变
     + 外部状态：不可以共享，会随环境变化而改变
3. 享元模式的实现
   + FlyweightFactory享元工厂类
     + 创建并管理享元对象，享元池一般设计成键值对
   + FlyWeight抽象享元类
     + 通常是一个接口或抽象类，声明公共方法，这些方法可以向外界提供对象的内部状态，设置外部状态。
   + ConcreteFlyWeight具体享元类
     + 为内部状态提供成员变量进行存储
   + UnsharedConcreteFlyWeight非共享享元类
     + 不能被共享的子类可以设计为非共享享元类

4. 优点：
   + 极大减少内存中对象的数量
   + 相同或相似对象内存中只有一份，极大的节约资源，提高系统性能
   + 外部装填相对独立，不影响内部状态
5. 缺点：
   + 模式比较复杂，是程序逻辑复杂化
   + 为了节省内存，共享了内部状态，分离出外部状态，而读取外部状态，使运行时间变长。用时间换取了空间
6. 享元模式就相当于，复用相似的内容（同一类的内容），然后把不同的内容（其他类）独立出来，这样就可以减少冗余数据，但是花费时间会增长。

### 责任链模式

> 能够将处理同一请求的对象连成一条线

1. 责任链模式就相当于我们请假的流程，这个过程就可以连接成一条线，班主任处理不了的，传递给年级主任，年级主任处理不了的传递给主任。。。。，依次套娃。

### 迭代器模式(iterator)

> 遍历聚合对象的方式

```java
public class ConcreteMyAggregate {
    private List<Object> list = new ArrayList<>();

    public void addObject(Object obj) {
        this.list.add(obj);
    }

    public void removeObject(Object obj) {
        this.list.remove(obj);
    }

    public List<Object> getList() {
        return list;
    }

    public void setList(List<Object> list) {
        this.list = list;
    }

    public MyIterator createIterator() {
        return new ConcreteIterator();
    }


    // 使用内部类定义迭代器，可以直接使用外部类的属性
    private class ConcreteIterator implements MyIterator {

        private int cursor; // 定义游标用于记录遍历时的位置

        @Override
        public void first() {
            cursor = 0;
        }

        @Override
        public void next() {
            if (cursor <list.size()) {
                cursor++;
            }
        }

        @Override
        public boolean hasNext() {
            if (cursor < list.size()) {
                return true;
            }
            return false;
        }

        @Override
        public boolean isFirst() {
            return cursor == 0 ? true : false;
        }

        @Override
        public boolean isLast() {
            return cursor == (list.size() - 1) ? true : false;
        }

        @Override
        public Object getCurrentObj() {
            return list.get(cursor);
        }
    }
}
public interface MyIterator {
    void first(); // 将游标指向第一个元素
    void next(); // 将游标指向下一个元素
    boolean hasNext(); // 判断是否存在下一个元素
    boolean isFirst();
    boolean isLast();

    Object getCurrentObj(); // 获取当前游标指向对象
}

```



### 中介者模式(Mediator)

> 通过一个中间变量来活动，不用产生复杂的网状结构，避免了许多个体之间的关联

1. 中介者模式就是将复杂的网络结构，通过中介来简化。
2. 就比如说你去注册公司，然后需要跟很多部门打交道，这很麻烦，也很费时间。然而通过中介，你只需要给一些东西，它就可以帮你完成。减少了需要注册公司的人和部门之间的关联。

### 命令模式(command)

1. Command抽象命令类
2. ConcreteCommand具体命令类
3. Invoker调用者/请求者
   + 请求的发送者，它通过命令对象来执行请求。一个调用者并不需要在设计师确定其接收者，因此它只与抽象命令类之间存在关联。在程序运行时，将调用命令对象的execute()，间接调用接收者的相关操作。
4. Receiver接收者
   + 接收者执行与请求相关的操作，具体实现对请求的业务处理。
   + 未抽象前，实际执行操作内容的对象。
5. Client客户类
   + 在客户类中需要创建调用者对象、具体命令类对象，在创建具体命令对象时指定对应的接收者。发送者和接收者之间没有直接关系，都通过命令对象间接调用。
6. 这个就相当于我拿对讲机给在不同地点的大家发布指令，我只需要发布就行了，不需要找到你。（这玩意有点抽象）

### 解释器模式(Interpreter)

1. 是一种不常用的设计模式
2. 当我们需要开发一种新的语言时，可以考虑使用解释器模式
3. 尽量不要使用解释器模式，后期维护会有很大麻烦。在项目中，可以使用Jruby，Groovy，java的js引擎来代替解释器的作用，弥补java语言的不足。
4. 开发场景：
   + 语法解释器
   + 数学正则表达式

### 访问者模式(Visitor)

1. 模式动机：

+ 对于存储在一个集合中的对象，他们可能具有不同的类型9即使有一个公公的接口），对于该集合中的对象，可以接受一类称为访问者的对象来访问，不同的访问者其访问方式也有所不同。

2. 定义：

+ 表示一个作用于某结构中的个元素的操作，他是我们可以在不改变元素的类的前提下定义作用于这些元素的新操作。

3. 开发场景：

+ XML文档解释器
+ 编译器的设计
+ 复杂集合对象的处理

### 策略模式(strateqy)

1. 场景：
   + 不同客户产品的报价（报价策略）

### 模板方法模式(template method)

方法回调（钩子函数）

1. 什么时候使用模板方法模式
   + 实现一个算法时，整体步骤很固定。但是，某些部分易变。易变部分可以抽象出来，供子类实现。

### 状态模式(state)

1. 核心：
   + 用于解决系统中复杂对象的状态转换以及不同状态下行为的封装问题
2. 结构：
   + Context环境类
     + 环境类中维护一个State对象，他是定义了当前的状态
   + State抽象状态类
   + ConcreteState具体状态类
     + 每一个类封装了一个状态对应的行为。

3. 开发场景：
   + 银行系统中的帐号状态的管理
   + OA系统中公文状态的管理
   + 酒店系统中，房间状态的管理
   + 线程对象各状态之间的切换。

### 观察者模式(observer)

> javaSE提供了java.util.Observable和java.util.Observer来实现观察者模式

1. 观察者模式就相当于一个广播。
2. 聊天室程序，一个人将消息发给服务器，服务器转发给所有的客户端

### 备忘率模式(memento)

1. 核心
   + 就是保存某个对象内部状态的拷贝，这样以后就可以将该对象恢复到原先的状态。
2. 结构
   + 源发器类Originator
   + 备忘录类Memento
   + 负责人类CareTake

