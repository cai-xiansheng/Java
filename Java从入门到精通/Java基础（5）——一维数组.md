# Java一维数组

### 声明数组变量

> elementType[] arrayRefVar;（元素类型[] 数组引用变量；）

elementType可以是任何数据类型，但是数组中的所有元素都必须具有相同的数据类型。下边就是一个实例：代码声明变量myList，它引用的是一个double类型的数据元素。

>double[] myList;

不仅可以用上面的方式，还有C语言中常用的elemetType arrayRefVar[]，这种风格是C语言中常用的，但是在Java中还是推荐第一种声明方法。

声明数组就是给数组一个可以应用它的地址，并不给它分配存储空间，分配存储空间在创建数组时再扩充空间。声明就只是给了一个可以找到它的地址，还给大家说有这么个东西，以后用的时候，大家可以通过它来创建一个数组，但是你要用我创建数组，你就要服从我的规矩（也就是元素类型必须和我要求的类型相同）。

### 创建数组

> arrayRefVar = new elementType[arraySize];

new了一个与声明类型相同的数组，并且给这个数组给了一定的空间。然后把新创建的数组给引用赋值的变量，也就是我们对应类型声明的变量。

##### 其实我们可以将数组的声明与创建在同一行完成(就是直接把他们连接到一块)

> elementType[]  arrayRefVar = new elementType[arraySize];

> elementType arrayRefVar[] = new elementType[arraySize];

同时声明并且创建就是将声明与创建连接到一块。下面就是一个实例：

> double[]  myList = new double[10];

### 数组的初始化

初始化数组就是给已经创建的数组赋值。

在赋值之前我们需要考虑到数组被创建之后它的默认初始值：数据型的初始值就是0，char的默认初始值就是“\u0000”，Boolean型的默认值就是false。

数组的下边跟我们之前接触到的下标相同，都是从0开始。

数组的初始化有以下三种方式：

```java 
elementType[] arrayRefVar = {value0,value1,……};
//这种就是将声明、创建、初始化一次完成。
elementType[] arrayRefVar;
arrayRefVar = {value0,value1,……};
//这种是先初始化和创建数组，然后再初始化。
elementType[] arrayRefVar = new elementType[10];
arrayRefVar[0] = value0;
……
arrayRefVar[9] = value9;
//这种就是先初始化创建，然后再初始化。
```

### for-each循环

```java
for (elementType element : arrayRefVar){
    //对元素的操作
}
```

for-each 就是将数组中每个元素都访问到，它也是通过下标访问。

### 数组的复制

不能通过赋值来复制数组，如果这样只会把两个数组名指向同一个地址，这样并不能达到复制的效果。

数组的复制可以通过一下三种方法：

> 使用循环，将元素逐个复制给新的数组。

> 使用方法arraycopy。

> 使用clone方法复制。（目前不知道它是个什么东西，只知道有这么个东西）

### 给方法传递参数

这块跟前边一样，都涉及到一个问题：传递的是实参（实参就是我写了一份东西，我把它重新复制了一份，然后把复制的这份给你，你爱怎么折腾就怎么折腾，完全与我无关）还是传递的引用（引用就相当于给一个人起了两个名字，不管你给那个名字发送要求它都会影响内部的变化）。

所以在参数传递的时候就会遇到这个问题，如果你给方法传递的是一个实参（实参就是一个值），那么不管它怎么改变都不会改变原来的值，它只不过能利用我们给他的值；如果我们传递的是一个数组（传递的数组其实就是传递进去一个指向数组地址的标志），这样我们在操作的时候就是直接操作的数组。所以数组就会发生变化。

### 可变长参数列表

> typeName...parameterName (类型名...参数名)

（...）必不可少；这儿只能给方法中指定一个可变长度参数，同时这个参数必须是最后一个参数，任何常规参数必须跟在它之前。这个东西可能用处不大，谁会用一个不准确的东西!!

### 查找元素

##### 线性查找

一个一个对比着找

##### 二分法查找

对半分着查找。但是这个必须时一个排序好的东西，这样才可以准确查找。这就跟我们学的《计算方法》中的二分法一样。

### 插入排序

终于知道了除了毛泡排序法以外的第二中排序法。

##### 插入排序的实现：

首先逐个循环，从第二个元素（索引为1）开始。然后将这个元素赋值给一个变量，循环判断逐个变量跟前边的元素大小关系，如果没找到就把对比的元素往后挪一位，直到找到合适的位置在把我们的变量插入进去。这样就完成了一次插入排序。再逐个循环就可以完成排序。

### Arrays类

##### 排序sort()

sort()可以直接把一个数组排序（这儿的排序国际标准的排序），后面也可以加限制条件，限制排序的范围：

> sort(chars,1,3);	这个就是将数组的char[1]到char[3]的数据进行排序处理。

##### 二分法binarySearch(数组,key)

就是把二分法封装起来了，我们可以直接调用，所有的方法都是如此。

##### 检测数组是否相等

> equals(list1,list2);	这个东西好像经常遇见，但在每种语言中的使用格式都不太相同。它的返回值时布尔值。

##### 填充数组fill(数组,要添加的元素)

> 这个小东西的格式还是蛮秀的：fill(list1,5);这个就是给数组中所有的元素全部填充5.

> fill(list1,1,3,8);这个是给列表中的list[1]到list[3]全部填充8。

#### 后话

数组还是当初的数组，只不过给我们提供了很多操作的方法而已。准确理解变量与内存的关系，每个东西之间的关系也尤为重要，如果理解了，就可以快速的掌握后面的操作。所以基础太重要了！！！

